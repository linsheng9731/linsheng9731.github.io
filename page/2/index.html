<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>记录是为了更好的创造</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="记录是为了更好的创造">
<meta property="og:url" content="https://linsheng9731.github.io/page/2/index.html">
<meta property="og:site_name" content="记录是为了更好的创造">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录是为了更好的创造">
  
    <link rel="alternate" href="/atom.xml" title="记录是为了更好的创造" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">记录是为了更好的创造</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://linsheng9731.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ying-yong-ceng-huan-cun" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/24/ying-yong-ceng-huan-cun/" class="article-date">
  <time datetime="2018-03-24T08:07:27.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/24/ying-yong-ceng-huan-cun/">应用层缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓存系统是业务系统中常见的组件，在某些场景下技术需要保系统能够尽可能的快速响应，同时系统返回的资源又是很少被更改的，这时候可以使用缓存来提系统的响应速度。缓存系统从类型上来看可以分为内存型缓存和分布式缓存。第一种就是在程序内部使用的缓存，一般是一个map结构。第二种是通过网络请求存取资源的分布式缓存，比如redis-cluster，aerospike。内存型缓存虽然速度优于分布式缓存，但是它的容量有限，在要求不是特别高的情况下，可以直接选择分布式缓存以降低系统设计的复杂度。如果对速度要求极高，那么可以采取一些优化措施。</p>
<h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h2><p>在内存型缓存中使用LRU结构来解决容量不足的问题，同时保证较高的命中率。LRU是一种cpu缓存管理算法，基本原理是：给每个缓存对象设置年龄，每次命中对象年龄加1，碰到需要更新缓存的情况，优先替换年龄最小的记录。但是在具体实现中一般不会严格去记录对象的生命周期，因为这样开销太大了。常见的LRU实现使用双向链表和哈希表，如下图所示：<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15218760273398.jpg" alt="">￼<br>链表中每个节点都记录前一个记录和后一个记录，使用head和tail来标记链表的头和尾。同时使用哈希表来存储记录，保证在获取操作的开销最小。当一个记录被命中，把它从链表中取出再连接到头部。当需要替换一个记录时，直接替换链表的最后一条记录。虽然没有严格记录每个记录的年龄，但是近似达到了LRU的效果。下面是scala版本的实现：</p>
<pre><code>/**
  * Cache
  *
  * @author damon lin
  *         2018/3/22
  */
trait Cache[K,V] {

  def get(key: K): Option[V]

  def put(key: K, value: V): Unit

  def batchPut(values: Seq[(K, V)]): Unit

  def values(): Seq[V]

}

private[this] sealed trait Pointer[K, V] {
  var pre: Pointer[K, V]
  var next: Pointer[K, V]
}

private[this] case class Node[K, V](override var pre: Pointer[K, V], override var next: Pointer[K, V], key: K, value: V) extends Pointer[K, V]
private[this] case class NullNode[K, V](override var pre: Pointer[K, V], override var next: Pointer[K, V]) extends Pointer[K, V]

class LruCache[K, V](cap: Int) extends Cache[K, V] {

  require(cap &gt; 0)

  def this() = this(10000) // default cap is 10000

  private[this] val map = new mutable.HashMap[K, Node[K, V]]
  private[this] val entries = new Array[Pointer[K, V]](cap)
  private[this] val head_ : NullNode[K, V] = NullNode(entries(0), entries(0))
  private[this] val tail_ : NullNode[K, V] = NullNode(entries(0), entries(0))
  private[this] val count = new AtomicInteger(1)

  entries(0) = head_
  entries(1) = tail_

  def batchPut(values: Seq[(K, V)]): Unit = {
    values.foreach {
      case (key, value) =&gt;
        put(key, value)
    }
  }

  // todo: synchronized is not a efficient solution
  @ThreadSafe
  override def put(key: K, value: V): Unit = {
    this.synchronized {
      val index = count.get()
      if (index &lt; cap - 1) {
        entries(index + 1) = tail_
        val n = newNode(key, value, index)
        map(key) = n
        count.incrementAndGet()
      } else {
        val old = tail_.pre.asInstanceOf[Node[K, V]]
        val n = Node(old.pre, old.next, key, value)
        tail_.pre = n
        map -= old.key
        map(key) = n
      }
    }
  }

  @ThreadSafe
  override def get(key: K): Option[V] =  {
    val n = map(key)
    // pick out n
    n.pre.next = n.next
    n.next.pre = n.pre
    // append n to head
    val h = head_.next
    n.next = h
    h.pre = n
    head_.next = n
    map.get(key).map(_.value)
  }

  override def values(): Seq[V] = {
    map.values.toList.map(_.value)
  }

  private[this] def newNode(key:K, value: V, index: Int) = {
    val pre = entries(index - 1)
    val next = entries(index + 1)
    val n = Node(pre, next, key, value)
    entries(index) = n
    pre.next = n
    next.pre = n
    n
  }
}
</code></pre><h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><p>引入多级缓存。多级缓存的原理很好理解，和cpu的多级缓存设计一样，在应用层同时引入内存型缓存和分布式缓存。因为读数据库的开销要远远大于读分布式缓存的开销，所以多级缓存能提高性能。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15218766368205.jpg" alt="">￼</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片不能提高记录的访问速度，但是能够提高系统整体的吞吐量。系统架构设计如下如所示：<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15218767684986.jpg" alt="">￼<br>在服务前引入openresty，采用一致性哈希算法做负载均衡。这样对于同样的url能够定向到同一台服务器上，相比随机算法，一致性哈希能够大大提高缓存的命中率，能够减少因为命中失败引起的网络请求。但是分片后会带来另一个问题：数据热点。因为一致性哈希是根据url来重定向请求的，可能会发生大量请求被转到同一台服务器上，导致服务瘫痪。解决方案是降级处理热点请求，在LB后面引入一层openresty，对于热点请求降级为随机算法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>应用层缓存可以提供系统响应速度，对于一些不经常被更改的资源可以加入缓存系统。使用LRU解决内存型缓存的容量问题，引入多级缓存可以优化内存型缓存失效的场景。而对于一些量级很大的资源，引入分片机制增加系统吞吐量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/24/ying-yong-ceng-huan-cun/" data-id="cjlyygoky004hf7vatvkrz5v4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala-typeclass" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/21/scala-typeclass/" class="article-date">
  <time datetime="2018-03-21T03:53:40.000Z" itemprop="datePublished">2018-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/21/scala-typeclass/">Scala TypeClass</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>TypeClass 是一个强大而灵活的概念，它将特殊的多态性添加到Scala中。<br>TypeClass 首先在Haskell中引入，作为一种多态的新方法。TypeClass 是一个类（组），在trait中定义某个契约，并且可以添加针对不同类型的具体实，而不需要对原始代码进行任何更改。可以说通过扩展一个简单的 trait 可以实现同样的目标，但是对于 TypeClass，事先并不需要显示的在代码中编写这种需求。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们来编写一个 TypeClass，它会拥有一个 show 方法，接受任意类型的参数，返回它们的字符串表示。类似于内置的 .toString：</p>
<pre><code>trait Show[A] {
  def show(a: A): String
}

object Show {
  val intCanShow: Show[Int] =
    new Show[Int] {
      def show(int: Int): String = s&quot;int $int&quot;
    }
}
</code></pre><p>然后我们可以这样使用：</p>
<pre><code>println(intCanShow.show(20))
</code></pre><p>看上去很简单，但是对于调用者而言似乎有些不太方便，因为需要知道太多细节，比如对于 Int 类型需要指定 intCanShow 变量。而且对于不同的类型需要了解的细节是不一样的，总而言之就是不太灵活。针对这个问题我们引入了隐式转化，让编译器自己去寻找合适的 show。</p>
<pre><code>object Show {
  def apply[A](implicit sh: Show[A]): Show[A] = sh

  def show[A: Show](a: A) = Show[A].show(a)

  implicit class ShowOps[A: Show](a: A) {
    def show = Show[A].show(a)
  }

  implicit val intCanShow: Show[Int] =
    new Show[Int] {
      def show(int: Int): String = s&quot;int $int&quot;
    }
}
</code></pre><p>所以我们可以这样来使用 show：</p>
<pre><code>println(30.show)
</code></pre><p>看上去好很多，调用者终于可以忽略细节。来仔细看一下实现，当编译器遇到 30.show 的时候，他会在语言内置的环境下去寻找，发现 Int 类型没有 show 方法，然后他会抛出一个异常丢给隐式转化。隐式转化会找到 ShowOps 定义，得到 Show[A].show(a)，Show[A] 等价于 Show.apply[A]，同时根据类型 Int 得到 intCanShow，最后调用 <code>def show(int: Int): String = s&quot;int $int&quot;</code>。</p>
<p>上面的实现就是 typeclass，让我们添加更多针对不同类型的实现：</p>
<pre><code>implicit val stringCanShow: Show[String] =
  new Show[String]{
    def show(str: String): String = s&quot;string $str&quot;
  }
</code></pre><p>这样我们就有了对 Int，String两种类型都有了 show 方法。仔细观察一下上面的实现就可以发现除了针对不同类型做不同操作之外，其他代码对于所有的 typeclass 是有共通的部分的。所以就产生了一些类库来做这个事情。比较常用的是 <a href="https://github.com/mpilquist/simulacrum" target="_blank" rel="noopener">Simulacrum</a>，对于上面的实现如果改用 simulacrum 可以做到非常简化：</p>
<pre><code>import simulacrum._

@typeclass trait ShowSim[A] {
  def showSim(a: A): String
}

object ShowSim {
  implicit val stringCanShow: ShowSim[String] =
    str =&gt; s&quot;simulacrum string $str&quot;
}
</code></pre><p>只需要定义扩展的名称，以及扩展对于不同类型的具体实现即可。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于 typeclass 其实没有特别神奇的地方，它是一种对既有类型增强的通用模式。通过组合 trait，泛型，以及隐式转化就可以很轻松的实现 typeclass。如果在这个基础上使用宏，则可以大大简化代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/21/scala-typeclass/" data-id="cjlyygokc0035f7vaerj6nq5c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-postgresql-di-gui-cha-xun" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/21/postgresql-di-gui-cha-xun/" class="article-date">
  <time datetime="2018-03-21T03:49:49.000Z" itemprop="datePublished">2018-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/大数据/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/21/postgresql-di-gui-cha-xun/">Postgresql 递归查询</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>pg(postgresql)和sql server支持递归查询，在一些需要描述树形结构的场景下可以使用递归查询简化表设计。在介绍递归查询之前需要先了解一下WITH语句，WITH语句通常被称为通用表表达式（Common Table Expressions）或者CTEs。CETs作为一个辅助语句依附于主语句，CTEs和主语句可以使用select，insert，update，delete中的任意一种。</p>
<h2 id="WITH语句"><a href="#WITH语句" class="headerlink" title="WITH语句"></a>WITH语句</h2><p>使用WITH语句可以把多个复杂的查询拆分，举一个官方给的例子：</p>
<pre><code>WITH regional_sales AS (
  SELECT region, SUM(amount) AS total_sales
  FROM orders
  GROUP BY region
), top_regions AS (
  SELECT region
  FROM regional_sales
  WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales
)
SELECT
  region,
  product,
  SUM(quantity) AS product_units,
  SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</code></pre><p>WITH定义了两个辅助语句，分别得到regional_sales和在这个基础上筛选出来的top_regions。主句是一个select查询，引用了辅助语句产出的结果。</p>
<h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p>WITH加上RECURSIVE可以实现递归查询，这里还是看一个具体的例子：在数据库中存储一颗树，命名表为t1。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15216126594176.jpg" alt="">￼</p>
<p>t1表有三个字段，分别是：id, category, parent_id。每条记录代表树中的一个节点，其中parent_id用于存储节点的父节点。现在我想查出C4这个节点下面的所有子节点：</p>
<pre><code>WITH RECURSIVE CTE AS (
    SELECT *, nextval(&apos;t1_id_seq&apos;) new_id FROM t1 WHERE id = 4
    UNION ALL
    SELECT t1.*, nextval(&apos;t1_id_seq&apos;) new_id FROM CTE JOIN t1 ON CTE.id = t1.parent_id
)
SELECT C1.new_id, C1.category, C2.new_id new_parent_id
FROM CTE C1 LEFT JOIN CTE C2 ON C1.parent_id = C2.id
</code></pre><p>WITH RECURSIVE的辅助语句由两个部分组成：第一个是递归的起始点，第二部分是递归查询的条件。上面的例子，我们以id=4这个节点作为递归查询的起点，定义递归查询条件 CTE.id = t1.parent_id，即下一条记录的parent_id要等于上一条记录的id。最终得到结果：</p>
<pre><code>new_id  category    new_parent_id
------  --------    -------------
9       C4          
10      C5          9
11      C6          9
12      C7          10
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>pg提供的递归查询在表达树和图的数据结构时，的确很有优势。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/21/postgresql-di-gui-cha-xun/" data-id="cjlyygojn001sf7va5sp7rsx2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shu-ju-ku-suo-yin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/16/shu-ju-ku-suo-yin/" class="article-date">
  <time datetime="2018-03-16T03:50:51.000Z" itemprop="datePublished">2018-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/大数据/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/16/shu-ju-ku-suo-yin/">数据库索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构,<br>这里的B树，也就是英文中的B-Tree，一个 m 阶的B树满足以下条件：<br>* 每个结点至多拥有m棵子树；<br>* 根结点至少拥有两颗子树（存在子树的情况下）；<br>* 除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；<br>* 所有的叶结点都在同一层上；<br>* 有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；<br>* 关键字数量需要满足ceil(m/2)-1 &lt;= n &lt;= m-1；</p>
<p>下面是一个B-数的例子：<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15211791551533.jpg" alt="">￼<br>上面的结构有个问题，需要查找的目标值不是都在叶子节点上的，这就需要进行一次中序遍历来查找。而B+的改进则是将所有的值都存储在叶子节点，上层节点只做索引用，B+树的搜索过程中事实上是走了一条从根结点到叶子结点的路径。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15211765882949.jpg" alt="">￼</p>
<p>B+树相对其他树的优势是什么？这就和计算机的磁盘有关了，一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，这个过程耗费的时间叫做旋转时间。</p>
<p>为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<br>* 当一个数据被用到时，其附近的数据也通常会马上被使用。<br>* 程序运行期间所需要的数据通常比较集中。</p>
<p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p>
<h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><p>InnoDB和MyISAM是mysql中两个存储引擎，虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15211798005196.jpg" alt="">￼</p>
<h2 id="主索引和辅助索引"><a href="#主索引和辅助索引" class="headerlink" title="主索引和辅助索引"></a>主索引和辅助索引</h2><p>主码索引：就是使用主键建立的索引。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>辅助索引。辅助索引是相对于主码索引而言的。在MyISAM中，辅助索引的结构和主码索引的结构是一样的，都是采用的是B+树结构，且叶子节点存储的都是数据记录的地址。而InnoDB中虽然也采用的是Ｂ＋树存储，但是辅助索引的叶子节点存储的是对应于主码索引的主键。也就是说如果你通过辅助索引查找数据，要先在Ｂ＋树中查找到主键，然后根据主索引查找到对应的记录，查找两次。应为这个原因，要求主键数据长度不能太长，因为辅助索引中叶子节点存储主键值，太长会导致辅助索引的额外存储空间太大。</p>
<h2 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。</p>
<p>第二种情况是根据选择性来判断，选择性：(不重复的索引值) / (表记录数)<br>选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。举个例子一张表里有id和gender两列，id是自增，gender只有两个值，如果使用gender作为查询索引，那么只能做一次二分，之后就得根据id进行遍历，复杂度是n。相反，如果使用id，可以在logn内查到记录。</p>
<h2 id="BitMap索引"><a href="#BitMap索引" class="headerlink" title="BitMap索引"></a>BitMap索引</h2><p>上文讲到对于gender这种属性可能的值只有两个，选择性很小不适合用B+数建立索引，对于这种情况可以使用bitmap来建立索引。对于gender这个列，位图索引形成两个向量，男向量为10100…，向量的每一位表示该行是否是男，如果是则位1，否为0，同理，女向量位01011。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15211801565737.jpg" alt="">￼<br>对于婚姻状况这一列，位图索引生成三个向量，已婚为11000…，未婚为00100…，离婚为00010…。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15211801797618.jpg" alt="">￼<br>当我们使用查询语句“select * from table where Gender=‘男’ and Marital=“未婚”;”的时候 首先取出男向量10100…，然后取出未婚向量00100…，将两个向量做and操作，这时生成新向量00100…，可以发现第三位为1，表示该表的第三行数据就是我们需要查询的结果。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/03/15211802050625.jpg" alt="">￼<br>　此外，位图索引适合静态数据，而不适合索引频繁更新的列。如果某个列需要被频繁更新，那么对应的位图索引也会被频繁更新，这些操作通常消耗比较大。  
　</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010</p>
<p>[2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006</p>
<p>[3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011</p>
<p>[4] <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/16/shu-ju-ku-suo-yin/" data-id="cjlyygokn003tf7vapwf03z8p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sql-tiao-jian-yu-ju" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/15/sql-tiao-jian-yu-ju/" class="article-date">
  <time datetime="2018-03-15T09:19:29.000Z" itemprop="datePublished">2018-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/大数据/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/15/sql-tiao-jian-yu-ju/">sql 条件语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在某些场景下需要对表中的某些字段进行条件判断，然后设置或者返回不同的值，简单说就是条件判断。sql提供了case…when结构来实现这一功能，case又具有两种格式：简单case函数和case搜索函数。</p>
<p>第一种 格式 : 简单Case函数 :</p>
<p>格式说明  </p>
<p>　　　　case 列名<br>　　　　when 条件值1 then 选择项1<br>　　　　when 条件值2 then 选项2…….<br>　　　　else 默认值 end<br>eg:</p>
<pre><code>　　　　select 
　　　　case 　　job_level
　　　　when     &apos;1&apos;    then    &apos;1111&apos;
　　　　when　  &apos;2&apos;     then    &apos;1111&apos;
　　　　when　  &apos;3&apos;     then    &apos;1111&apos;
　　　　else    &apos;eee&apos; 
　　　　end
　　　　from     dbo.employee
</code></pre><p>第二种 格式 :Case搜索函数</p>
<p>格式说明  </p>
<p>　　　　case  </p>
<p>　　　　when 列名= 条件值1 then 选择项1<br>　　　　when 列名=条件值2 then 选项2…….<br>　　　　else 默认值 end<br>eg:</p>
<pre><code>　　　　update  employee
　　　　set     e_wage =
　　　　case
　　　　when   job_level = &apos;1&apos;   then e_wage*1.97
　　　　when   job_level = &apos;2&apos;   then e_wage*1.07
　　　　when   job_level = &apos;3&apos;   then e_wage*1.06
　　　　else   e_wage*1.05
　　　　end
</code></pre><p>需要注意case函数只返回第一个符合条件的值，剩下的case部分将会被自动忽略。</p>
<p>下面看一个具体的例子来体会一下case：</p>
<p>country</p>
<p>population</p>
<p>中国</p>
<p>600</p>
<p>美国</p>
<p>100</p>
<p>加拿大</p>
<p>100</p>
<p>英国</p>
<p>200</p>
<p>法国</p>
<p>300</p>
<p>日本</p>
<p>250</p>
<p>德国</p>
<p>200</p>
<p>墨西哥</p>
<p>50</p>
<p>印度</p>
<p>250</p>
<p>根据上述这个表来统亚洲，北美洲和其他洲的人口数量。使用case来解决这个问题：</p>
<pre><code>SELECT  SUM(population),
CASE country
WHEN &apos;中国&apos;     THEN &apos;亚洲&apos;
WHEN &apos;印度&apos;     THEN &apos;亚洲&apos;
WHEN &apos;日本&apos;     THEN &apos;亚洲&apos;
WHEN &apos;美国&apos;     THEN &apos;北美洲&apos;
WHEN &apos;加拿大&apos;  THEN &apos;北美洲&apos;
WHEN &apos;墨西哥&apos;  THEN &apos;北美洲&apos;
ELSE &apos;其他&apos; END
FROM    Table_A
GROUP BY CASE country
WHEN &apos;中国&apos;     THEN &apos;亚洲&apos;
WHEN &apos;印度&apos;     THEN &apos;亚洲&apos;
WHEN &apos;日本&apos;     THEN &apos;亚洲&apos;
WHEN &apos;美国&apos;     THEN &apos;北美洲&apos;
WHEN &apos;加拿大&apos;  THEN &apos;北美洲&apos;
WHEN &apos;墨西哥&apos;  THEN &apos;北美洲&apos;
ELSE &apos;其他&apos; END;
</code></pre><p>最后可以的到如下结果:</p>
<p>country</p>
<p>population</p>
<p>亚洲</p>
<p>1100</p>
<p>北美洲</p>
<p>250</p>
<p>其他</p>
<p>700</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/15/sql-tiao-jian-yu-ju/" data-id="cjlyygokr0043f7vadc7c6kqa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sql-over-han-shu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/15/sql-over-han-shu/" class="article-date">
  <time datetime="2018-03-15T08:32:47.000Z" itemprop="datePublished">2018-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/大数据/">大数据</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/15/sql-over-han-shu/">sql over 函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>over() 函数是对分析函数的一种条件解释，直接点就是给分析函数加条件吧。<br>下面看两个例子：</p>
<pre><code>　select 
　a.empno as 员工编号,
　a.ename as 员工姓名,
　a.deptno as 部门编号,
　a.sal as 薪酬,
　sum(sal) over (partition by deptno) 按部门求薪酬总和 from scott.emp a;
</code></pre><p>上述sql的运行结果是：</p>
<p>部门编号</p>
<p>员工姓名</p>
<p>员工编码</p>
<p>薪酬</p>
<p>按部门薪酬总和</p>
<p>7934</p>
<p>MILLER</p>
<p>10</p>
<p>1300</p>
<p>8750</p>
<p>7782</p>
<p>CLARK</p>
<p>10</p>
<p>2450</p>
<p>8750</p>
<p>可以从结果上看到sum()函数对部门区分进行了求和统计。其中“partition by”官方点的说法叫做”分区”，其实就是统计的范围条件。</p>
<p>分级函数rank必须和over一起使用，否则会报错。</p>
<pre><code>select 
a.empno as 员工编号,
a.sal as 薪资,
a.job as 岗位,
rank() OVER(partition by a.job ORDER BY a.sal desc) as 岗位薪资等级 from scott.emp a;
</code></pre><p>上述sql返回的结果如下：</p>
<p>员工编号</p>
<p>薪资</p>
<p>岗位</p>
<p>等级</p>
<p>7902</p>
<p>3000</p>
<p>ANALYST</p>
<p>1</p>
<p>6900</p>
<p>1300</p>
<p>CLERK</p>
<p>2</p>
<p>可以看出over函数是对rank函数的补充，类似select…when，partition by a.job 表示先按照job字段进行分区，在每个区内按照薪水排序，最后应用rank函数，给出每条记录的等级。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/15/sql-over-han-shu/" data-id="cjlyygokp0040f7vaken59mb4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rchain-rosette-gui-fan-fu-he-gou-zao-compound-cons" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/rchain-rosette-gui-fan-fu-he-gou-zao-compound-cons/" class="article-date">
  <time datetime="2018-03-10T06:40:36.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/rchain-rosette-gui-fan-fu-he-gou-zao-compound-cons/">Rchain Rosette规范 复合构造（Compound constructs）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="5-复合构造（Compound-constructs）"><a href="#5-复合构造（Compound-constructs）" class="headerlink" title="5 复合构造（Compound constructs）"></a>5 复合构造（Compound constructs）</h2><p>使用第4节的简单表达式和命令来组建复合构造。这个章节将讲述以下几个方面：块，条件和绑定构建。</p>
<h3 id="5-1-块（block）"><a href="#5-1-块（block）" class="headerlink" title="5.1 块（block）"></a>5.1 块（block）</h3><p>基本语法：(block 〈expr〉 〈expr〉 …)<br>块表达式打包了一组并行计算的的表达式。 同时，“并行”意味着表达式可以以任何顺序执行，并且块表达式的语义不应该取决于任何特定的顺序。块接受到的延续（continuation）会成为块中每个表达式的延续。这是块和通信结构组件之间的关键区别。通信构造组件建立新的延续，参与者接收结果并将其打包在消息结构中。块不构建任何新的延续; 它将它的延续转发给块内的表达式。</p>
<p>如果表达式是发送表达式，则结果不会延续。 如果表达式是一个请求表达式，那么结果会在请求中传播。 对于其他表达式，情况与请求的情况类似。 例如，常量表达式只是在遇到常量时自行返回结果。</p>
<p>由于块中的所有表达式都会得到相同的continuation，因此可以直接在竞争表达式中表示“竞争”，多个表达式产生的第一个结果将成为该块的结果。 稍后的结果（如果有的话）将被忽略。 以下示例说明了块构造中固有的非确定性：</p>
<p>(block 1 2 3 4) ⇒ 1 or 2 or 3 or 4</p>
<p>上面的例子是块的“自然”语义的结果。块构造的传统用法只有一个表达式会产生结果。 所有其他表达式将被发送，或其他复合表达式不会产生结果。</p>
<p>(block<br>(update balance (+ balance amount))<br>[’credited amount])</p>
<p>在上面的例子中，更新余额的操作不会产生任何结果，而两个值（’credited和amount）被发送，继续等待块结果。 如果遇到可能会产生多个结果的块，则会发出警告。</p>
<p>(seq expr 1 … expr n ) ⇒ result n special form</p>
<p>上面这种形式的表达式用于计算一个序列中的表达式，并将最后一个表达式的结果作为seq的结果返回。这种形式的计算可以使用Rosette的set!,label和goto来表达，否则需要另外实现一种方式。这中迭代功能在大部分I/O系统和Rosette中作为语法扩展提供。除了在这种特殊的情况下，这种表达式应该极少被使用。每个表达式expri都必须返回一个结果，因为这是Actor模型中可以表达因果关系的唯一方法。因此，如果以seq格式使用send，它应该被void修饰（见下文）。</p>
<h3 id="5-2-条件（Conditionals）"><a href="#5-2-条件（Conditionals）" class="headerlink" title="5.2 条件（Conditionals）"></a>5.2 条件（Conditionals）</h3><p>（if 1 2）  </p>
<p>（if 1 2 3）</p>
<p>这两种形式提供了常规的if-then和if-then-else控制结构，其中then和else部分不被计算，除非条件为真。 如果1的计算结果为#t，则第一个形式返回2的结果，如果条件计算结果为#f，则返回#niv。 第二种形式的行为与第一种不同，除了对#f的情况返回3的结果。 如果1不计算为布尔值，则将其视为#t。</p>
<p>(if #t 1) ⇒ 1<br>(if #f 1) ⇒ #niv<br>(if (= y 0) 0 (% x y)) ⇒ 0 or (% x y)</p>
<p>(cond (〈test〉 1 〈body〉 1 ) (〈test〉 2 〈body〉 2 ) …) derived syntax<br>(cond (〈test〉 1 〈body〉 1 ) (〈test〉 2 〈body〉 2 ) … (else 〈body〉 e )) derived syntax</p>
<p>cond的常见用法是用于多个（通常是互斥的）条件并行测试。同时计算多个i，并计算测试结果为真的i对应的i，并将结果返回到整个cond；如果存在多于一个结果为真的i，则一个i被随机地选择用于计算。如果所有的i都被计算，并且结果都没有#t，同时一个else子句被指定，则评估e;否则cond的结果是#niv。如果不是所有的i都完成并且完成的结果中没有#t，那么cond将不会终止。为了确保cond的结果是确定性的，需要通过编写每个i来终止，以便对于所有i，只有一个计算为#t，如下所示：</p>
<p>(cond ((&lt;= amount balance)<br>(update balance (- balance amount))<br>[’withdrew amount])<br>((> amount balance)<br>(update) [’overdraft (- amount balance)]))</p>
<h3 id="5-3-绑定构造（Binding-constructs）"><a href="#5-3-绑定构造（Binding-constructs）" class="headerlink" title="5.3 绑定构造（Binding constructs）"></a>5.3 绑定构造（Binding constructs）</h3><p>绑定结构让let*和letrec提供给Rosette一个块结构，就像在Common Lisp或Scheme中一样。 这些构造和变量绑定不同。</p>
<p>(let [[〈id or pattern〉 〈expr〉] …] 〈body〉) special form</p>
<p>会被并行的计算，然后根据相应的绑定结果。 然后会在已经绑定变量的环境下执行。的结果返回到在let发生位置。 在绑定中使用以允许返回多个值。（有关语法的更多信息，请参见6.1节）。</p>
<p>(let <a href="*%20x%20y">[x 2] [y 3]</a>) ⇒ 6<br>(let* [[〈id or pattern〉 〈expr〉] …] 〈body〉) derived syntax</p>
<p>let<em> 用于嵌套多个lets结构：<br>(let</em> <a href="+%20x%20y%20z">[x 2] [y (+ x 1)]<br>[x (+ y 4)] [z (+ x 9)]</a>))<br>⇒ 26</p>
<p>(letrec [[〈id〉〈expr〉] …] 〈body〉) special form</p>
<p>〈id〉s 最初被绑定到“虚拟的”actors上，并且成为〈expr〉s的结果。这些绑定被运用到当前的计算环境下。〈expr〉s在这种环境下进行并行的计算。每条expr〉会产生一个结果，并且这些结果会对应的替换初始的“虚拟的”actors。然后body会在整个letrec的环境下开始进行计算。</p>
<p>(letrec [[even? (proc <a href="if%20(=%20n%200">n</a>%20#t%20(odd?%20(-%20n%201))))]</p>
<p>[odd? (proc <a href="if%20(=%20n%200">n</a>%20#f%20(even?%20(-%20n%201))))]] (even? 88)) ⇒ #t</p>
<p>在这个例子中，这两个表达式（参见第6.2节）在一个环境中进行评估，在这两个环境中 even? 和 odd? 被赋予全新的绑定。因此，这两个表达式将被包含在同一个环境中，它们彼此可见。</p>
<h3 id="5-4-迭代（Iteration）"><a href="#5-4-迭代（Iteration）" class="headerlink" title="5.4 迭代（Iteration）"></a>5.4 迭代（Iteration）</h3><p>(iterate 〈id〉 [[〈id〉1 〈expr〉1 ] …] 〈body〉) ⇒ any derived syntax</p>
<p>迭代是在过程和方法中引入循环的一种形式。可以在中使用以重复。i同时进行计算，并且最初绑定到i，的计算是在绑定i的环境中进行。 如果需要重复循环，则请求的形式为：<br>(〈id〉 〈expr〉 …)<br>使用由确定的绑定再次进行计算。 以下示例计算12的阶乘：</p>
<p>(iterate loop <a href="if%20(%3C%20n%202">[n 12] [r 1]</a>%20r%20(loop%20(dec%20n)%20(*%20r%20n))))</p>
<p>⇒ 479001600</p>
<p>(do [[1 1 1] …] [(1 1) …] ) =&gt; any<br>(do* [[1 1 1] …] [(1 1) …] ) =&gt; any</p>
<p>这两个表单同时计算i并将结果绑定到i。 然后，在一个使用绑定了扩展的环境中评估i，如果没有#t，则在相同的环境中评估，评估i 并将其绑定到i，并重复该过程。do和 do<em> 这两种形式在i的计算方式上有所不同。在执行i的情况下，对于 do</em>，它们按文本顺序进行计算，并且随后的可能取决于由前面的建立的绑定。 例如，</p>
<p>(do [[last #niv (new List n last)]<br>[n 1 (inc n)]]<br>[((= n N) (new List n last))])</p>
<p>上面的例子是一个简单的循环，它构建NList的actor，使得列表的头部的actor为N，并且后续的List actor将值逐渐递减到1。变量last最初是#niv，n最初为1。终止条件是（= n N），此时会创建一个最终的List actor作为循环的结果。通过循环的连续步骤，最后一个绑定到一个新的List actor，当前值为n，并链接到最后的当前值，同时n递增。在这个例子中，是空的，这是不常见的，因为所有的计算都可以在i中执行。</p>
<h3 id="5-5-其他形式（Miscellaneous-forms）"><a href="#5-5-其他形式（Miscellaneous-forms）" class="headerlink" title="5.5 其他形式（Miscellaneous forms）"></a>5.5 其他形式（Miscellaneous forms）</h3><p>接下来的内容覆盖以下形式：free, goto, label, set!, 还有 void。</p>
<p>(free [〈id〉 …] 〈body〉) ⇒ result of 〈body〉 special form</p>
<p>free形式通知编译器在中被视为自由的; 否则，编译器将发出警告：没有编译时绑定。有时候这正是所期望的。例如其中一个标识符持有在某个实体的所有后代之间共享的值，或者是一个继承的“本地”方法。 通常编译器会警告表明在定义方法或过程时发生了错误。在这种情况下，使用free表示通过继承来查找，可以消除编译器的警告。</p>
<p>接下来的三种形式主要用于构建表单的内部结构，比如前一节中的迭代结构和其他系统代码。<br>(goto 〈id〉) ⇒ no result<br>(label 〈id〉 〈body〉) ⇒ result of 〈body〉<br>(set! 〈id〉 〈expr〉) ⇒ any</p>
<p>goto和label形式提供了一个基本的循环结构。本质上，goto只能向后分支，前向分支是通过if完成的。 set!是一种原始分配，允许在程序改变绑定。</p>
<p>(void 〈body〉) ⇒ #niv derived syntax</p>
<p>void表示一次计算并不会真正产生结果。编译器将在可能需要产生结果的上下文中发出警告，例如过程或方法的主体。编译器比较保守，因为追踪由这种错误可能非常困难。一种常见症状是活动停止太久，因为actor未解锁。 void的形式如下：</p>
<p>(void 〈body〉) expands to (block #niv 〈body〉)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/10/rchain-rosette-gui-fan-fu-he-gou-zao-compound-cons/" data-id="cjlyygojv0028f7va8o23hb9c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rchain/">rchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-clique-gong-shi-suan-fa-zhuan-zai" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/clique-gong-shi-suan-fa-zhuan-zai/" class="article-date">
  <time datetime="2018-03-10T06:36:40.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/clique-gong-shi-suan-fa-zhuan-zai/">Clique共识算法[转载]</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在以太坊中，默认使用ethash（pow）共识算法进行网络正确性的保障，这种共识算法采用的是工作量证明的机制，也就是我们所熟知的“挖矿”。</p>
<p>除了主网络，以太坊社区还提供了测试网络供dapp开发者进行开发调试。由于dapp的运行需要消耗一定的gas，在测试网络中进行开发调试，可以帮助开发者节省经济成本。</p>
<p>以太坊的第一个测试网络<strong>Morden</strong>从2015年7月开始运行，直至2016年的11月，由于不同客户端之间不共识的问题，导致区块链分叉而被弃用。</p>
<p>以太坊的第二个测试网络<strong>Ropsten</strong>与此同时被部署，直至运行到2017年的2月，由于测试网络本身算力不足，恶意攻击者在网络中传递巨大的区块数据，导致整体网络瘫痪，造成区块链分叉，测试网络再次不可用。</p>
<p><strong>Ropsten</strong>网络瘫痪的根本原因是测试网络中没有足够算力来支撑ethash共识算法，导致共识算法失去作用。即便是重新部署一个测试网络，也无法解决该问题，因此，所有工作量证明类的算法都不适用于测试网络。</p>
<p>自然而然，大家把目光转向了casper（pos）共识算法，但是casper算法距离真正使用仍有一段距离，为了弥补这段时间内的空缺，以太坊go team的leader <em>Péter Szilágyi</em>提出了一种基于认证的共识算法<strong>Clique</strong>。这种算法的原理十分简单，即网络中的每一个区块是由某一个<em>认证节点</em>进行认证的，其他节点仅需要验证<em>认证信息</em>来判断该区块是否合法。</p>
<h3 id="区块认证"><a href="#区块认证" class="headerlink" title="区块认证"></a>区块认证</h3><h4 id="节点类别"><a href="#节点类别" class="headerlink" title="节点类别"></a>节点类别</h4><p>在介绍算法原理之前，首先介绍一下在clique算法中，节点的分类。</p>
<p>节点可以分为两类：</p>
<ul>
<li>认证节点</li>
<li>非认证节点</li>
</ul>
<p>前者具有为一个区块签名的权利，可以对应pow算法中的矿工节点；</p>
<p>后者不具备签名的权利，是区块链网络中的普通同步节点；</p>
<p>两者可以相互转换，而这种<em>动态管理所有认证节点的机制</em>也是clique算法的难点与精髓之一。</p>
<h4 id="认证原理"><a href="#认证原理" class="headerlink" title="认证原理"></a>认证原理</h4><p>clique中使用的认证原理非常简单，借用了<strong>椭圆曲线数字签名算法</strong>进行实现。</p>
<p>每一个认证节点，可以利用本地节点的私钥对一个区块的数据进行签名，并将产生的数字签名放置在区块头中；</p>
<p>其他节点在接收到该区块后，利用数字签名和区块数据反解出签名节点的公钥信息，并截取出相应的节点地址，若该节点地址在本地节点所维护的<em>认证节点列表中</em>，且该区块通过所有共识相关的检测，则认为该区块是合法的；否则就认为接收到了一个恶意区块。</p>
<p>为了不破坏区块本身的数据结构，clique在实现时复用了之前定义的字段，将认证节点的签名放在区块头的extraData字段中。</p>
<p><img src="./pic/clique_authority.jpeg" alt=""></p>
<h4 id="机会均等"><a href="#机会均等" class="headerlink" title="机会均等"></a>机会均等</h4><p>为了使得出块的负载（或者说是机会）对于每个认证节点尽量均等，同时避免某些恶意节点持续出块，clique中规定每一个认证节点在连续的<code>SIGNER_LIMIT</code>个区块中，最多只能签发一个区块，也就是说，每一轮中，最多只有<code>SIGNER_COUNT - SIGNER_LIMIT</code>个认证节点可以参与区块签发。</p>
<p>其中<code>SIGNER_LIMIT = floor(SIGNER_COUNT / 2) + 1</code>，<code>SIGNER_COUNT</code>表示认证节点的个数。</p>
<p>这样设计的目的：</p>
<p>在保证_好<em>节点的个数大于</em>坏<em>节点的前提下，</em>好_节点最少的个数为<code>SIGNER_LIMIT</code>（大于50%），坏节点最多的个数为<code>SIGNER_COUNT - SIGNER_LIMIT</code>（小于50%）。一个节点在<code>SIGNER_LIMIT</code>这个时间窗口内最多只能签发一个区块，这就使得恶意节点在不超过50%的情况下，从理论上无法一直掌握区块的签发权。</p>
<p><img src="./pic/clique_signer_limit.jpeg" alt=""></p>
<h4 id="难度计算"><a href="#难度计算" class="headerlink" title="难度计算"></a>难度计算</h4><p>在以太坊中，每个节点都会维护一条<strong>难度总值最大</strong>的区块链作为主链，在其他叉链上的区块成为叔区块。因此为了兼容现有的架构，clique中同样有难度值这个概念。</p>
<p>为了让每个认证节点都有均等的机会去签发一个区块，每个节点在签发时都会判断本节点是不是本轮的“inturn”节点，若是inturn节点，则该节点产生的区块难度为2，否则为1。每一轮仅有一个节点为inturn节点。</p>
<p>判断当前节点是否为inturn节点的方法十分简单，将本地维护的认证节点按照字典序排序，若当前区块号除以认证节点个数的余数等于该节点的下标，则该节点为inturn节点。</p>
<pre><code>// inturn returns if a signer at a given block height is in-turn or not.
func (s *Snapshot) inturn(number uint64, signer common.Address) bool {
    signers, offset := s.signers(), 0
    for offset &lt; len(signers) &amp;&amp; signers[offset] != signer {
        offset++
    }
    return (number % uint64(len(signers))) == uint64(offset)
}
</code></pre><p>为inturn节点设计更高难度值的目的是：使得区块链能够朝着某一个方向进行收敛。倘若所有节点签发区块的难度没有区别，则会出现多条难度相同的叉链导致网络无法达成共识。</p>
<p>但是即便inturn节点能够签发高难度区块，其他节点竟然会参与竞争。这是因为inturn节点可能在此期间处于离线状态，其他节点可以弥补inturn节点的空缺，继续为网络签发区块。不过这也就会导致这一轮可能会有若干条不同状态的区块链产生（因为其他节点签发的难度值相同），这种状态最终会通过下一轮或者下几轮inturn节点签发的高难度区块而达到收敛。</p>
<p><strong>缺陷</strong></p>
<p>inturn节点拥有签发高难度区块的权利，从理论上来说，也就是“预定”了本轮区块竞赛最终的胜者会是这个inturn节点，这也是clique算法不完备的地方，恶意攻击者可以预知每一轮的出块者，并且提前向他发起攻击。</p>
<h4 id="区块分发"><a href="#区块分发" class="headerlink" title="区块分发"></a>区块分发</h4><p>clique算法每一轮出块的间隔时间是可配置的，假设每一轮出块的时间配置为10秒，那么每个认证节点在完成一个区块的签名流程后，会计算当前区块的时间戳，计算方式为父区块的时间加上10秒，并且延迟至该时间才向外广播区块。</p>
<p>但是在一轮区块竞赛中，网络中会有<code>SIGNER_COUNT</code> - <code>SIGNER_LIMIT</code>个认证节点可以参与签发区块，为了<strong>避免网络拥堵</strong>以及不必要的<strong>区块链重组</strong>，在每个节点完成签发，分发区块之前，采用了非inturn节点延迟分发的优化。</p>
<p>具体的策略为非inturn节点随机延迟<code>rand(SIGNER_LIMIT)*500ms</code>的时间，而inturn节点不增加额外的延迟时间。</p>
<pre><code>// Sweet, the protocol permits us to sign the block, wait for our time
    delay := time.Unix(header.Time.Int64(), 0).Sub(time.Now())
    if header.Difficulty.Cmp(diffNoTurn) == 0 {
        // It&apos;s not our turn explicitly to sign, delay it a bit
        wiggle := time.Duration(len(snap.Signers)/2+1) * wiggleTime
        delay += time.Duration(rand.Int63n(int64(wiggle)))
    }
    select {
    case &lt;-stop:
        return nil, nil
    case &lt;-time.After(delay):
    }
</code></pre><blockquote>
<p>区块链重组：</p>
<p>由于在以太坊网络中，每个节点接收到不同”矿工“节点产生的区块时间不同，因此可能产生首先接收到了一个难度值较低的区块，随后又接收到了一个难度值更高且处于同一高度的新区块，当发生这种这种情况时，便会进行区块链头部的切换，以总难度值最大的区块链为主链。</p>
</blockquote>
<p><img src="./pic/chain_reorg.jpeg" alt=""></p>
<h4 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h4><p>普通节点在收到一个新区块时，会从区块头的extraData字段中取出认证节点的签名，利用标准的<code>spec256k1</code>椭圆曲线进行反解公钥信息，并且从公钥中截取出签发节点的地址，若该节点是认证节点，且该节点本轮拥有签名的权限，则认为该区块为合法区块。</p>
<h3 id="基于投票的认证节点维护"><a href="#基于投票的认证节点维护" class="headerlink" title="基于投票的认证节点维护"></a>基于投票的认证节点维护</h3><p>clique的区块认证机制十分简单，难点在于如何动态地维护认证节点列表信息。因此，clique中采用了一种基于投票的认证节点维护机制。</p>
<p>首先先介绍几个基本概念：</p>
<ul>
<li><p><strong>signer</strong></p>
<p>认证节点</p>
</li>
<li><p><strong>purposal</strong></p>
<p>用户可以利用rpc接口发起一次purposal，指定要加入或移除某一个认证节点。一个purposal的结构为（1）需要改变状态的认证节点的地址（2）新状态；</p>
</li>
<li><p><strong>vote</strong></p>
<p>每个<strong>认证节点</strong>在每一轮<strong>签发区块</strong>时，都会从<code>pending</code>的purposal池里随机挑选一个purposal，并将purposal的目标节点地址填在<code>beneficiary</code>字段中，将新状态填在<code>nonce</code>字段中，以此作为一次投票；</p>
</li>
<li><p><strong>tally</strong></p>
<p>每个认证节点本地会维护一个投票结果计数器tally，其中记录了每一个被选举节点（1）新状态&lt;加入或移除&gt; （2）已经获取的票数。一旦获得票数超过半数，就立即更改认证节点的状态；</p>
</li>
</ul>
<p>clique的一次投票流程如下图所示：</p>
<ol>
<li>用户通过rpc接口发起一次请求，要求对地址为a的节点进行状态变更，将其从普通节点变为认证节点或者从认证节点变为普通节点。生成的请求会缓存在本地的purposal池中，等待应用；</li>
<li><strong>本地认证节点</strong>在一次区块打包的过程中，从purposal池中随机挑选一条<em>还未被应用</em>的purposal，并将信息填入区块头，将区块广播给其他节点；</li>
<li>其他节点在接收到区块后，取出其中的信息，封装成一个vote进行存储，并将投票结果应用到本地，若关于目标节点的状态更改获得的一致投票超过半数，则更改目标节点的状态：<ol>
<li>若为新增认证节点，将目标节点的地址添加到本地的认证节点的列表中；</li>
<li>若为删除认证节点，将目标节点的地址从本地的认证节点列表中删除；</li>
</ol>
</li>
</ol>
<p>较为复杂的情况是删除一个认证节点。由于认证节点的减少，导致之前还未到达共识的purposal由于节点数的减少而达到了一致，也就是说在一次投票应用的过程中，可能会有多个purposal同时达到满足条件，针对这种情况，clique规定在一个投票应用中，只能对<code>beneficiary</code>字段指定的地址进行状态变更，而对于其他的purposal，需要等待到下一次<code>beneficiary</code>与其目标地址一致时才可以被触发。</p>
<p><img src="./pic/clique_vote.jpeg" alt=""></p>
<p><strong>注意</strong>：由于可能发生区块链重组的情况，因此即便一个新的认证节点被加入，或者被删除，都有可能发生<strong>回滚</strong>。</p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>为了防止某些恶意节点不断地发起purposal，导致每个节点在内存中维护大量的投票统计信息，clique加入了一个checkpoint机制。每隔一个<code>epoch</code>，所有节点将pending状态的投票信息、统计信息都删除，并在这个区块头中填入当前所有认证节点的地址信息，供其他节点进行一次状态同步。</p>
<p>这样做的优势是：</p>
<ol>
<li>避免了维护统计信息无限增大的内存开销；</li>
<li>使得新加入的节点不必要从头同步区块数据，来重放投票过程生成认证节点地址列表，而直接通过checkpoint的区块获取完整的认证节点地址（例如fast sync）；</li>
</ol>
<p><strong>注意</strong>：可以看到，其实与区块数据一样，认证节点信息在各个节点的每一个阶段也都是严格的一致的！换一句话说，认证节点的信息也是<strong>“编码”</strong>在区块信息中的。例如初始的认证节点信息被编码在创世区块的区块头中。所有新加入的节点通过不断重放投票过程可以得到相同的认证节点信息。这也就能够保证新节点加入时，无论采用哪种同步方式（normal, fast, light, warp），都能够在每一个阶段得到一致的结果。</p>
<h3 id="搭建Clique私有网络"><a href="#搭建Clique私有网络" class="headerlink" title="搭建Clique私有网络"></a>搭建Clique私有网络</h3><p>在介绍了clique算法的实现原理后，在本章中简要介绍一下如何利用<code>puppeth</code>工具快速地搭建一个基于clique共识算法的私有网络。</p>
<p><strong>准备环境</strong></p>
<p>首先从<a href="https://ethereum.github.io/go-ethereum/downloads/" target="_blank" rel="noopener">https://ethereum.github.io/go-ethereum/downloads/</a>下载go-ethereum即辅助工具，创建四个节点的目录，并在每个节点目录下创建一个账户。</p>
<pre><code>mkdir node1 node2 node3 node4
for i in 1 2 3 4; do geth --datadir node$i/data account new; done
</code></pre><p><strong>生成genesis文件</strong></p>
<p>利用puppeth工具生成使用clique算法的genesis文件</p>
<pre><code>$ puppeth
+-----------------------------------------------------------+
| Welcome to puppeth, your Ethereum private network manager |
|                                                           |
| This tool lets you create a new Ethereum network down to  |
| the genesis block, bootnodes, miners and ethstats servers |
| without the hassle that it would normally entail.         |
|                                                           |
| Puppeth uses SSH to dial in to remote servers, and builds |
| its network components out of Docker containers using the |
| docker-compose toolset.                                   |
+-----------------------------------------------------------+

Please specify a network name to administer (no spaces, please)
&gt; garden


Sweet, you can set this via --network=garden next time!

INFO [11-21|13:42:36] Administering Ethereum network           name=garden
WARN [11-21|13:42:36] No previous configurations found         path=/Users/gary/.puppeth/garden

What would you like to do? (default = stats)
 1. Show network stats
 2. Configure new genesis
 3. Track new remote server
 4. Deploy network components
&gt; 2


Which consensus engine to use? (default = clique)
 1. Ethash - proof-of-work
 2. Clique - proof-of-authority
&gt; 2


How many seconds should blocks take? (default = 15)
&gt; 10
# 选择一个节点账号作为创始的认证节点
Which accounts are allowed to seal? (mandatory at least one)
&gt; 0xe4b38fb40123740a6fdce5da8e4faebc663c0b7f
&gt; 0x
# 选择若干个账户为其添加初始以太币
Which accounts should be pre-funded? (advisable at least one)
&gt; 0xe4b38fb40123740a6fdce5da8e4faebc663c0b7f
&gt; 0xe29513049a329c1e1e54e366b42434ccf49dcf48
&gt; 0x


Specify your chain/network ID if you want an explicit one (default = random)
&gt;

Anything fun to embed into the genesis block? (max 32 bytes)
&gt; None
</code></pre><p>然后利用puppeth工具导出，即可在当前目录中看到生成的genesis文件。</p>
<pre><code>What would you like to do? (default = stats)
 1. Show network stats
 2. Manage existing genesis
 3. Track new remote server
 4. Deploy network components
&gt; 2

 1. Modify existing fork rules
 2. Export genesis configuration
&gt; 2

Which file to save the genesis into? (default = garden.json)
&gt;
INFO [11-21|13:46:14] Exported existing genesis block
</code></pre><p><strong>应用genesis</strong></p>
<pre><code>for i in 1 2 3 4; do geth --datadir node$i/data init garden.json; done
</code></pre><p><strong>启动节点</strong></p>
<p>从genesis文件中查到networkId，并以此启动四个节点（注意网络Id必须与genesis区块中记载的是一致的，且每个node对应的端口号须不一样，unlock的账号也为本节点对应的账号）</p>
<pre><code>geth --datadir node1/data --networkid 18904 --port 10001 --unlock 139af9691eee4836550461b1b631eee1af958a35 console
</code></pre><p><strong>添加对端节点</strong></p>
<p>每个节点在网络中都会有一个唯一的标识enode，该信息可以从节点启动日志中读取。由于目前该网络中没有一个bootnode，因此四个节点即使在同一个网络中，也无法进行互联，所有我们在node2,node3,node4中依次添加node1的信息，使得这三个节点都与node1组成一个星状网络。</p>
<pre><code>admin.addPeer(&quot;enode://54790190c258daef3b220dfd0ed06233d52cb6ed30eb74c576b739941ad37422bcf895cb06baa975f7f5ad4f69dbea19d7fbe9106cf539adf43d4007b576cacc@127.0.0.1:10001&quot;)
</code></pre><blockquote>
<p>注意要把@后的ip地址改为127.0.0.1</p>
</blockquote>
<p>完成以后，在node1中查看已经连接的对端点，可以看到已经有三个对端点了</p>
<pre><code>admin.peers
</code></pre><p><strong>启动clique</strong></p>
<p>还记得我们在配置genesis的时候，将节点1中的账户添加到了sealer中了，即node1已经具备了认证区块的资格了，在node1中输入以下命令，node1就开始正常工作了。</p>
<pre><code>miner.start()
</code></pre><p><strong>新增认证节点</strong></p>
<p>目前网络中共有1个认证节点node1，根据算法，只需要超过一半的认证节点同意新增该节点，该节点即可变成一个新的认证节点，因此在这里只需要由node1发起一个purposal，即可添加新的认证节点。</p>
<pre><code># 将node2添加进认证节点中
clique.propose(&quot;0xe29513049a329c1e1e54e366b42434ccf49dcf48&quot;, true)


cique.getSnapshot()
{
  hash: &quot;0x75b5997bc31547aa3cb2d0ccd1de707a0bfc3a827b98c11951dbdce8cbcf72d2&quot;,
  number: 58,
  recents: {
    58: &quot;0xe4b38fb40123740a6fdce5da8e4faebc663c0b7f&quot;
  },
  signers: {
    0xe29513049a329c1e1e54e366b42434ccf49dcf48: {},
    0xe4b38fb40123740a6fdce5da8e4faebc663c0b7f: {} # node2已经成为了新的认证节点
  },
  tally: {},
  votes: []
}
</code></pre><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><p>戎佳磊，浙江大学VLIS实验室在读研究生。</p>
<p>以太坊爱好者&amp;贡献者</p>
<p>趣链科技工程师&amp;hyperchain平台核心开发</p>
<p><a href="mailto:rongjialei@hyperchain.cn" target="_blank" rel="noopener">rongjialei@hyperchain.cn</a></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://medium.com/taipei-ethereum-meetup/%E4%BD%BF%E7%94%A8-go-ethereum-1-6-clique-poa-consensus-%E5%BB%BA%E7%AB%8B-private-chain-1-4d359f28feff" target="_blank" rel="noopener">https://medium.com/taipei-ethereum-meetup/%E4%BD%BF%E7%94%A8-go-ethereum-1-6-clique-poa-consensus-%E5%BB%BA%E7%AB%8B-private-chain-1-4d359f28feff</a></li>
<li><a href="https://github.com/ethereum/EIPs/issues/225" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/issues/225</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/10/clique-gong-shi-suan-fa-zhuan-zai/" data-id="cjlyygoio0003f7vau1p6sxm9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala-yin-shi-can-shu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/scala-yin-shi-can-shu/" class="article-date">
  <time datetime="2018-03-10T04:53:34.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/scala-yin-shi-can-shu/">scala隐式参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个方法可以有一个隐式参数列表，在参数列表的开始处由隐式关键字implicit标记。如果参数列表中的参数没有像往常一样传递，Scala会查看它是否可以获得正确类型的隐式值，如果可以，则自动传递它。斯卡拉将寻找这些参数的地方分为两类：<br>* Scala将首先查找隐含的定义和隐式参数，这些参数可以在调用具有隐式参数块的方法时直接访问。<br>* 然后，它会查找隐含在候选类型关联的所有伴随对象中的成员。</p>
<p>在下面的例子中，我们定义了一个方法sum，它使用monoid add和unit操作来计算元素列表的总和。</p>
<pre><code>abstract class Monoid[A] {
  def add(x: A, y: A): A
  def unit: A
}

object ImplicitTest {
  implicit val stringMonoid: Monoid[String] = new Monoid[String] {
    def add(x: String, y: String): String = x concat y
    def unit: String = &quot;&quot;
  }

  implicit val intMonoid: Monoid[Int] = new Monoid[Int] {
    def add(x: Int, y: Int): Int = x + y
    def unit: Int = 0
  }

  def sum[A](xs: List[A])(implicit m: Monoid[A]): A =
    if (xs.isEmpty) m.unit
    else m.add(xs.head, sum(xs.tail))

  def main(args: Array[String]): Unit = {
    println(sum(List(1, 2, 3)))       // uses IntMonoid implicitly
    println(sum(List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))) // uses StringMonoid implicitly
  }
}
</code></pre><p>Monoid定义了一个add操作，它结合了一对As并返回另一个A，还有一个称为unit的函数。</p>
<p>为了显示隐式参数是如何工作的，我们首先分别定义monoid StringMonoid和IntMonoid字符串和整数。该implicit关键字指示对应的对象可以被隐式地使用。</p>
<p>sum需要一个List[A]，并返回一个A，使用unit函数初始一个值，结合add方法。隐式参数m表示在调用sum函数的地方scala会在特定的范围内寻找对应的隐式转换定义，并正确额应用转换。</p>
<p>在main方法中，我们调用sum两次，只提供xs参数。Scala会在上面提到的范围内寻找隐含的参数m。第一个sum传递一个类型为List[Int]的xs，这意味着A是Int类型的。隐含的参数列表m被遗漏了，所以Scala会寻找一个隐式的类型Monoid[Int]。</p>
<p>第二个sum传入了List[String]，这意味着A是String类型。隐式查找的方式与之相同Int，但是这次将查找stringMonoid并自动将其作为m。</p>
<p>该程序将输出</p>
<pre><code>6
abc
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/10/scala-yin-shi-can-shu/" data-id="cjlyygokd0038f7vay7bnq4s6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala-zhong-dereturn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/scala-zhong-dereturn/" class="article-date">
  <time datetime="2018-03-10T04:07:39.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/scala-zhong-dereturn/">Scala中的return</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="return会打破程序结构"><a href="#return会打破程序结构" class="headerlink" title="return会打破程序结构"></a>return会打破程序结构</h2><p>scala中有return，语义和其他语言没什么区别，但是最好不要使用它。我们先看一个小例子:</p>
<pre><code>// Add two ints, and use this method to sum a list
def add(n:Int, m:Int): Int = n + m
def sum(ns: Int*): Int = ns.foldLeft(0)(add)

scala&gt; sum(33, 42, 99)
res0: Int = 174

// Same, using return 
def addR(n:Int, m:Int): Int = return n + m
def sumR(ns: Int*): Int = ns.foldLeft(0)(addR)

scala&gt; sumR(33, 42, 99)
res1: Int = 174
</code></pre><p>上面是一个sum函数，一个没有return就一个用了return，结果是一样的。但是，当我们通过内联add来进行重构addR。</p>
<pre><code>// Inline add and addR
def sum(ns: Int*): Int = ns.foldLeft(0)((n, m) =&gt; n + m) // inlined add

scala&gt; sum(33, 42, 99)
res2: Int = 174 // alright

def sumR(ns: Int*): Int = ns.foldLeft(0)((n, m) =&gt; return n + m) // inlined addR

scala&gt; sumR(33, 42, 99)
res3: Int = 33 // um.
</code></pre><p>所以发生了什么？当foldLeft碰到第一个return的时候直接返回了，在内联函数的情况下和我们预想的有些区别。再看看另一个例子：</p>
<pre><code>def foo: Int = { 
  val sumR: List[Int] =&gt; Int = _.foldLeft(0)((n, m) =&gt; return n + m)
  sumR(List(1,2,3)) + sumR(List(4,5,6))
}
</code></pre><p>分开看两个sumR的结果分别是1和4，所以相加的结果应该是5。但是实际结果却是1！。所以return打断了程序的运行，会产生意外的结果。</p>
<h2 id="return的类型"><a href="#return的类型" class="headerlink" title="return的类型"></a>return的类型</h2><p>接着往下看另一个例子：</p>
<pre><code>scala&gt; def foo: () =&gt; Int = () =&gt; return () =&gt; 1
foo: () =&gt; Int

scala&gt; val x = foo
x: () =&gt; Int = &lt;function0&gt;

scala&gt; x()
scala.runtime.NonLocalReturnControl
</code></pre><p>突然冒出一个奇怪的东西，scala.runtime.NonLocalReturnControl。这就要说一说在scala在lambda中的return是如何实现的了。因为对于匿名函数而言return无法达到函数的最外层，所以scala使用了异常机制，scala.runtime.NonLocalReturnControl是继承自NoStackTrace，而NoStackTrace来自Throwable，所以就有了上面的结果。所以在使用for之类的循环结构时，如果恰巧使用了return + lambda，则很有可能会抛出意想不到的异常。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>基于上面的几个场景，建议在任何情况下不要是用return，这个习惯会保护你避开上面几个奇怪的坑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/10/scala-zhong-dereturn/" data-id="cjlyygoke003bf7vazpn8xapx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/">Ansible</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/技术积累/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/运维/">运维</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/BlockChain/">BlockChain</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/BlockChain/技术积累/">技术积累</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/Marathon/">Marathon</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/Marathon/工具/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/Marathon/工具/技术积累/">技术积累</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Marathon/">Marathon</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Marathon/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Marathon/技术积累/运维/">运维</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/Web/">Web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/Web/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/Web/技术积累/未分类/">未分类</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/技术积累/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术积累/">技术积累</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/收藏/">收藏</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ansible/">Ansible</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Marathon/">Marathon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rchain/">rchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术文档/">技术文档</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ansible/" style="font-size: 12px;">Ansible</a> <a href="/tags/Marathon/" style="font-size: 16px;">Marathon</a> <a href="/tags/Scala/" style="font-size: 18px;">Scala</a> <a href="/tags/Web/" style="font-size: 16px;">Web</a> <a href="/tags/blockchain/" style="font-size: 20px;">blockchain</a> <a href="/tags/golang/" style="font-size: 12px;">golang</a> <a href="/tags/rchain/" style="font-size: 10px;">rchain</a> <a href="/tags/大数据/" style="font-size: 18px;">大数据</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/技术文档/" style="font-size: 14px;">技术文档</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/12/Spark-潜规则/">Spark 潜规则</a>
          </li>
        
          <li>
            <a href="/2018/06/11/yi-tai-fang-ri-zhi/">以太坊日志</a>
          </li>
        
          <li>
            <a href="/2018/04/28/kubernetes-kuai-su-shang-shou/">Kubernetes 快速上手</a>
          </li>
        
          <li>
            <a href="/2018/04/25/rchain-jian-zao-zheng-que-de-gong-shi-xie-yi/">Rchain 建造正确的共识协议</a>
          </li>
        
          <li>
            <a href="/2018/04/23/yi-tai-fang-xiang-guan-mi-ma-xue-suan-fa/">以太坊相关密码学算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Damon Lin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>