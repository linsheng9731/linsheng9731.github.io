<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>记录是为了更好的创造</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="记录是为了更好的创造">
<meta property="og:url" content="https://linsheng9731.github.io/page/3/index.html">
<meta property="og:site_name" content="记录是为了更好的创造">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录是为了更好的创造">
  
    <link rel="alternate" href="/atom.xml" title="记录是为了更好的创造" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">记录是为了更好的创造</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://linsheng9731.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-scala-de-lei-xing-yue-shu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/scala-de-lei-xing-yue-shu/" class="article-date">
  <time datetime="2018-03-10T03:44:23.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Scala/">Scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/scala-de-lei-xing-yue-shu/">Scala的类型约束</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="上下界约束-lt-gt"><a href="#上下界约束-lt-gt" class="headerlink" title="上下界约束 &lt;:,:&gt;"></a>上下界约束 &lt;:,:&gt;</h2><p>举个例子：</p>
<pre><code>def eat[A &lt;: Food, B &gt;: Fruit](a:A, b:B): Unit
</code></pre><p>A &lt;: Food的意思就是保证类型参数A是Food的子类（含本类），语法“A &lt;: B”定义了B为A的上界；同理相反的A&gt;:B的意思就是A是B的超类（含本类），定义了B为A的下界。</p>
<h2 id="协变和逆变-T-T"><a href="#协变和逆变-T-T" class="headerlink" title="协变和逆变 +T,-T"></a>协变和逆变 +T,-T</h2><p>和上面的上界，下界其实是差不多的语义，+T 协变是指能够使用与原始指定的派生类型相比，派生程度更大的类型。e.g. String =&gt; AnyRef。-T 逆变则是指能够使用派生程度更小的类型。e.g. AnyRef =&gt; String。</p>
<h2 id="view-bounds-视界-lt"><a href="#view-bounds-视界-lt" class="headerlink" title="view bounds(视界) &lt;%"></a>view bounds(视界) &lt;%</h2><p>&lt;%的意思是“view bounds”(视界)，它比&lt;:适用的范围更广，除了所有的子类型，还允许隐式转换过去的类型，但是需要注意无法对trait使用&lt;%。<br><code></code><br>scala&gt; trait A[T &lt;% Int]  </p>
<p><console>:1: error: traits cannot have type parameters with context bounds <code>: ...&#39; nor view bounds</code>&lt;% …’<br><code></code><br>可以使用子类或者隐式转化:</console></p>
<pre><code>def method [A &lt;% B](arglist): R = ...  
或者
def method [A](arglist)(implicit viewAB: A =&gt; B): R = ...  
</code></pre><h2 id="广义类型约束符号-：-，-lt-lt-lt-lt"><a href="#广义类型约束符号-：-，-lt-lt-lt-lt" class="headerlink" title="广义类型约束符号 =：=， &lt;:&lt;, &lt;%&lt;"></a>广义类型约束符号 =：=， &lt;:&lt;, &lt;%&lt;</h2><p>这些被称为广义的类型约束。他们允许你从一个类型参数化的class或trait，进一步约束其类型参数之一。下面是一个例子：</p>
<pre><code>case class Foo[A](a:A) { // &apos;A&apos; can be substituted with any type  
    // getStringLength can only be used if this is a Foo[String]  
    def getStringLength(implicit evidence: A =:= String) = a.length  
}  
</code></pre><p>这个隐式的参数 evidence 由编译器提供,A =:=String表示证明A是String类型（PS：即使A可以隐式转换成String类型也不行），因此参数a就可以调用a.length 而编译器不会报错。</p>
<p>&lt;:&lt; 和 &lt;%&lt; 使用类似, 有细微不同:<br>* A =:= B 表示 A 必须是 B 类型<br>* A &lt;:&lt; B 表示 A 必须是B的子类型 (类似于简单类型约束 &lt;:)<br>* A &lt;%&lt; B 表示 A 必须是可视化为 B类型, 可能通过隐式转换 (类似与简单类型约束 &lt;%)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/03/10/scala-de-lei-xing-yue-shu/" data-id="cjlyygok60031f7vaxokpa5q8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scala/">Scala</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rchain-jia-gou-wen-dang-fan-yi-casper" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/rchain-jia-gou-wen-dang-fan-yi-casper/" class="article-date">
  <time datetime="2018-01-24T02:36:01.000Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/rchain-jia-gou-wen-dang-fan-yi-casper/">Rchain 架构文档翻译（Casper）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/rchain/architecture-docs/blob/master/execution_model/consensus_protocol.rst" target="_blank" rel="noopener">原文</a></p>
<h2 id="Casper-共识算法"><a href="#Casper-共识算法" class="headerlink" title="Casper 共识算法"></a>Casper 共识算法</h2><p>网络中的验证节点负责维护区块链，使得全网状态达成一致。 验证者节点还需要确保区块链是自洽的，没有被篡改以及防止女巫攻击。</p>
<p>Casper 共识协议的几个方面使得参与者达成共识，包括以利益为基础的绑定，解绑定和周期性下注。 分布式共识协议的目的是为了确保横跨多个节点的区块链或部分区块链（基于命名空间）的一致性。 在错误频发的网络条件下，为了实现这一点，任何共识协议都应该产生一个确定的结果，并且证明协议的安全性和终止属性。</p>
<p>RChain 的共识协议使用以股份为基础的下注，类似于以太坊的 Casper 设计。 在开发者社区里这些协议被大家称为“股份证明”协议，但是这个标签导致了一些误解，很多人认为这样会导致权利过分集中。 验证人和股权委托绑定在一起，股权委托是一笔存放在托管合约中的保证金。 和以太坊相比，RChain不会只在一条链上的进行下注，RChain是按照逻辑提议来进行投注的。 提议是关于区块链的一系列陈述，例如：必须包括哪些交易（即，提议的状态转换），以何种顺序，哪些交易不应被包括，或者其他属性。 一个提议的具体例子是：“事务 t 应该发生在事务 s 之前”，“事务 r 不应该被包含”。</p>
<p>在某些汇合点处，验证者计算所有提议的最大共同子集。 有些时候，这个计算可能会非常困难，需要很长时间。 正因为如此，我们会需要一个超时机制，如果达到了规定的超时时间，验证者可以提出一个比较小的提议集合。一旦验证者对最大一致的提议子集达成共识，寻找下一个块就可以通过找到提议有效的最小模型而容易地实现。 对于这种设计，由于每个名称空间的事务隔离，所以大多数块可以并行合成。</p>
<p>我们来看看典型的工作流程：<br>* 验证者是一种节点角色。 每个验证者都会建立一个类似于债券的赌注，以确保其他验证者能工作良好。 如果他们不是一个好的验证者，那么这个股份就有被没收的风险。<br>* 客户端将事务请求发送给验证者。<br>* 接收到事务的验证者会创建一个包括最近交易的提议。</p>
<p><em>注意：只有在历史事务记录不一致时才会执行共识</em></p>
<p>在节点之间产生一轮下注周期：<br>1.原始验证者准备下注，这个赌注中包括以下内容：<br>_来源_ =下注的来源<br>_目标_ =下注的目标<br>_认领_ =认领赌注。 认领可以是一个区块，一个提议或者是一个最大一致的子集<br>_信心_ =代表玩家对发起认领中的证据拥有的信心。 这是验证者所使用下注策略的一种。<br>_理由_ =用于证明为什么这是一个合理的赌注。</p>
<p>2.验证者下注。<br>3.验证者会评估接受到的下注。 请注意，这些接受到的“理由”可以用来确定网络的各种属性。 例如，一个算法可以检测出模棱两可的情况，或者创建一个“理由”的图表，或者在下注的时候发现接受到了太多信息。 注意需要考虑攻击向量，以及博弈论应该如何被应用于协议设计。</p>
<p>投注周期朝着证明一个结果继续进行。 注意：<br>* 下注周期的目标是验证者节点在最大一致的提议集上达成共识。<br>* 能进行证明的一个前提条件是 2/3 的验证者的行为是合理的。<br>* 最终下注周期会逐渐收敛。<br>* 收敛过程中是部分同步的。<br>* 通过对提议下注，能够一次性合成更大块的区块链。 如果没有冲突，周期可以快速收敛。 这种方法的关键点是可以同时生成多个块。这种方式突破了块大小的限制。 关于这一点没有任何争论，因为最大的一致提议集合可以允许一次同意数百甚至数千个块。 相比现有的区块链而言，这将带来巨大的速度优势。<br>* 对于每个下注周期，验证者节点可能会赢得或失去他们的下注。</p>
<p>可扩展性是通过对提议进行精细划分并通过共识协议的嵌套（递归）来实现的。如果验证者在一组提议上达成一致性，并且证明在投注周期已经收敛，那么区块就可以通过协议被合成。 当前的下注周期结束。</p>
<p>对于更多相关信息详见：<br><a href="https://github.com/leithaus/pi4u/blob/master/cg/cg.pdf" target="_blank" rel="noopener">“共识游戏”：分析和比较广泛共识协议的公理化框架</a><br><a href="https://docs.google.com/document/d/1ZHaCXMlDZv-okGcRJ6P4-zWdqVDJSe-9bvEZe9jwpig/edit" target="_blank" rel="noopener">关于RChain共识议定书的更多细节，请参阅“投注逻辑 - 投注议案”</a><br><a href="https://www.reddit.com/r/ethereum" target="_blank" rel="noopener">要了解更多关于以太坊的 Casper 加入“以太坊研究Gitter”和“Reddit / ethereum”进行讨论</a></p>
<p>验证者的下注周期可以用一个迭代函数来表示，最终收敛对应于迭代函数中的不动点。通过这个原理，我们可以证明奖励与惩罚的收敛原则。我们可以给每一个验证者充分的自由度，唯一需要解决的是验证者所参与的下注行为是可收敛的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/24/rchain-jia-gou-wen-dang-fan-yi-casper/" data-id="cjlyygojq001yf7vak8v3htwm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-shi-yong-kong-xian-de-ying-pan-jin-xing-burst-wa-k" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/19/shi-yong-kong-xian-de-ying-pan-jin-xing-burst-wa-k/" class="article-date">
  <time datetime="2018-01-18T22:25:54.000Z" itemprop="datePublished">2018-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/19/shi-yong-kong-xian-de-ying-pan-jin-xing-burst-wa-k/">使用空闲的硬盘进行 Burst 挖矿</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Burst是一种加密货币，核心使用POC（容量证明）算法。与使用POW（工作证明）的区块链不同，矿工使用硬盘空间来挖掘新的区块并获得奖励。你有更多的容量，你就可以赚更多的代币。可以使用这个计算器来估算自己的<a href="http://burstcoincalculator.com/#calculator" target="_blank" rel="noopener">收益</a>。挖矿程序每4分钟从磁盘读取240MB的磁盘空间，并计算一些散列值，和比特币或者以太坊的算法相比非常节能。有点比较特殊，因为burst使用容量证明，所以在开始挖矿前你需要生成一些占位文件，称为plots文件。下面详细介绍如何在Linux Debian系统上进行挖矿。</p>
<h2 id="注册一个钱包"><a href="#注册一个钱包" class="headerlink" title="注册一个钱包"></a>注册一个钱包</h2><p>使用以下在线钱包创建一个帐户：<br><a href="https://wallet.burst-team.us:8126" target="_blank" rel="noopener">https://wallet.burst-team.us:8126</a><br><a href="https://wallet4.burstnation.com:8125" target="_blank" rel="noopener">https://wallet4.burstnation.com:8125</a><br>这个过程很简单,你的钱包有一个类似BURST-MWTK-BKY8-ZJ2W-37NKN的公共地址，在左上角找到它。任何人都可以使用这个地址给你转账。点击账户旁边的按钮“更多信息”，可以查看“数字帐户ID”，类似1893347256907199281的一个数字串。接下来可以从以下地址获取一些免费的代币<a href="http://burst.mininghere.com/faucet.php%EF%BC%8C%E6%88%96%E8%80%85%E4%BB%8E%E4%BA%A4%E6%98%93%E6%89%80%E8%B4%AD%E4%B9%B0%E3%80%82" target="_blank" rel="noopener">http://burst.mininghere.com/faucet.php，或者从交易所购买。</a></p>
<h2 id="生成plots文件"><a href="#生成plots文件" class="headerlink" title="生成plots文件"></a>生成plots文件</h2><p>plots文件生成需要一个单独的工具，下载并在本地编译。</p>
<pre><code>git clone https://github.com/r-majere/mjminer
cd mjminer
make
</code></pre><p>查看plot的使用方法：</p>
<pre><code>Usage: ./plot -k KEY [-x CORE] [-d DIRECTORY] [-s STARTNONCE] [-n NONCES] [-m STAGGERSIZE] [-t THREADS]
</code></pre><ul>
<li><p>KEY 应该是来自BURST在线钱包的“数字账户ID”的值。</p>
</li>
<li><p>CORE 是绘图生成算法的实现。您的CPU可能支持或不支持其中的一些（默认为0，SSE4为1，AVX2为2）。如果可能，尝试AVX2，否则尝试SSE4如果可能的话，否则使用默认值。 AVX2是最快的，默认是最慢的。</p>
</li>
<li><p>DIRECTORY plots文件的位置 。</p>
</li>
<li><p>STARTNONCE 你应该从0开始，如果有多个plots文件，下一个plots文件应该接上一个的值。</p>
</li>
<li><p>NONCES是plots文件的大小，除以256KB，所以价值4096意味着1GB。</p>
</li>
<li><p>STAGGERSIZE是绘图时可用的RAM大小（在随机数中），也就是4096表示1GB。</p>
</li>
<li><p>THREADS是要使用的线程数。尝试使用乘以2的物理内核的数量。</p>
</li>
</ul>
<p>下面是一个示例：</p>
<pre><code>./plot -k account id
990732 -x 2 -d ../data/ -s 0 -n 4096 -m 4096 -t 1
</code></pre><p>如果生成多个plots文件，文件之间的NONCES存在差距或者重叠了都不是问题，挖矿程序会正确处理这个问题。只要保证plots文件完好，如果plots文件被破坏了那么挖矿会受到影响，因为挖矿程序不能检查plots文件是否有效。</p>
<h2 id="编译挖矿程序"><a href="#编译挖矿程序" class="headerlink" title="编译挖矿程序"></a>编译挖矿程序</h2><p>官方没有Linux系统的挖矿程序，只有一个windows的图形界面。所以我们使用一个第三方的挖矿程序creepMiner。</p>
<pre><code>su
apt-get update
apt-get upgrade
apt-get install build-essential
apt-get install git
apt-get install openssl
apt-get install libssl-dev
apt-get install sudo
apt-get install cmake
git clone https://github.com/Creepsky/creepMiner.git
cd creepMiner
sh ./install-poco.sh
</code></pre><p>这里有点需要注意，这个挖矿程序使用c++14，所以需要g++的版本大于4.9。<br>如果版本过低需要更新g++的版本。</p>
<pre><code>add-apt-repository ppa:ubuntu-toolchain-r/test  
apt-get update  
apt-get install gcc-4.9 g++-4.9 cpp-4.9 gcc-4.9-locales g++-4.9-multilib libstdc++6-4.9-dbg gcc-4.9-multilib libgcc1-dbg libgomp1-dbg libitm1-dbg libatomic1-dbg libasan1-dbg liblsan0-dbg libtsan0-dbg libubsan0-dbg libcilkrts5-dbg libquadmath0-dbg lib32stdc++6-4.9-dbg libx32stdc++6-4.9-dbg  
apt-get install g++ 
update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 60 --slave /usr/bin/g++ g++ /usr/bin/g++-4.9
</code></pre><p>如果需要使用GPU来做计算还需要安装CUDA支持：</p>
<pre><code>apt install nvidia-cuda-toolkit
</code></pre><p>使用cmake生产Makefile</p>
<pre><code>for CPU + GPU:
cmake CMakeLists.txt

for CPU only:
cmake CMakeLists.txt -DNO_GPU=ON

for SSE2 only:
cmake CMakeLists.txt -DMINIMAL_BUILD=ON
</code></pre><p>最后执行make，二进制文件在bin目录下可以得到</p>
<pre><code>make
</code></pre><h2 id="开始挖矿"><a href="#开始挖矿" class="headerlink" title="开始挖矿"></a>开始挖矿</h2><p>挖矿需要加入一个矿池，这样能保证长期稳定的收益，而不是独自挖矿等待几个月的巨额回报。从这个文档里选择一个<a href="https://docs.google.com/spreadsheets/d/1KHu9BWwy_QXIYAx2m_Tzs9BqPoTYUDhEDbHihZEXGsE/edit#gid=327728699" target="_blank" rel="noopener">矿池</a>。我使用 <a href="http://pool.burstcoin.ro" target="_blank" rel="noopener">http://pool.burstcoin.ro</a> ，因为它会对DDOS进行保护。这里还需要进行最后一步设置，将奖励人设置为矿池的钱包地址，<br><a href="https://wallet.burst.cryptoguru.org:8125/rewardassignment.html" target="_blank" rel="noopener">设置地址</a>，分别输入秘钥和矿池的钱包地址，等待至少等待4个交易确认。下面是一个典型的配置矿工<br>mining.conf：</p>
<pre><code>{
    &quot;logging&quot; : {
        &quot;config&quot; : &quot;information&quot;,
        &quot;general&quot; : &quot;information&quot;,
        &quot;miner&quot; : &quot;information&quot;,
        &quot;nonceSubmitter&quot; : &quot;information&quot;,
        &quot;output&quot; : {
            &quot;dirDone&quot; : true,
            &quot;lastWinner&quot; : false,
            &quot;nonceConfirmed&quot; : true,
            &quot;nonceFound&quot; : true,
            &quot;nonceOnTheWay&quot; : true,
            &quot;nonceSent&quot; : true,
            &quot;plotDone&quot; : true
        },
        &quot;path&quot; : &quot;&quot;,
        &quot;plotReader&quot; : &quot;information&quot;,
        &quot;plotVerifier&quot; : &quot;information&quot;,
        &quot;server&quot; : &quot;fatal&quot;,
        &quot;session&quot; : &quot;error&quot;,
        &quot;socket&quot; : &quot;off&quot;,
        &quot;wallet&quot; : &quot;information&quot;
    },
    &quot;mining&quot; : {
        &quot;intensity&quot; : 3,
        &quot;maxBufferSizeMB&quot; : 128,
        &quot;maxPlotReaders&quot; : 0,
        &quot;passphrase&quot; : {
            &quot;algorithm&quot; : &quot;aes-256-cbc&quot;,
            &quot;decrypted&quot; : &quot;&quot;,
            &quot;deleteKey&quot; : false,
            &quot;encrypted&quot; : &quot;&quot;,
            &quot;iterations&quot; : 0,
            &quot;key&quot; : &quot;&quot;,
            &quot;salt&quot; : &quot;&quot;
        },
        &quot;plots&quot; : [
            &quot;/Volumes/HDD1&quot;,
            &quot;/Volumes/HDD2&quot;
        ],
        &quot;submissionMaxRetry&quot; : 3,
        &quot;targetDeadline&quot; : &quot;0y 20m 0d 00:00:00&quot;,
        &quot;timeout&quot; : 45,
        &quot;urls&quot; : {
            &quot;miningInfo&quot; : &quot;http://pool.burstcoin.ro:8080&quot;,
            &quot;submission&quot; : &quot;http://pool.burstcoin.ro:8080&quot;,
            &quot;wallet&quot; : &quot;http://pool.burstcoin.ro:8080&quot;
        }
    },
    &quot;webserver&quot; : {
        &quot;credentials&quot; : {
            &quot;hashed-pass&quot; : &quot;&quot;,
            &quot;hashed-user&quot; : &quot;&quot;,
            &quot;plain-pass&quot; : &quot;&quot;,
            &quot;plain-user&quot; : &quot;&quot;
        },
        &quot;start&quot; : true,
        &quot;url&quot; : &quot;http://127.0.0.1:8080&quot;
    }
}
</code></pre><p>运行矿工程序，控制台会输出类似下面的结果，burst挖矿之旅正式开始！</p>
<pre><code>MM:bin zzomrot$ ./burst-miner 
12:53:24: creepMiner 1.6.0 BSD x64
12:53:24: ----------------------------------------------
12:53:24: Github:   https://github.com/Creepsky/creepMiner
12:53:24: Author:   Creepsky [creepsky@gmail.com]
12:53:24: Burst :   BURST-JBKL-ZUAV-UXMB-2G795
12:53:24: ----------------------------------------------
12:53:24: Based on http://github.com/uraymeiviar/burst-miner
12:53:24: author : uray meiviar [ uraymeiviar@gmail.com ]
12:53:24: please donate to support developments :
12:53:24:  [ Burst   ] BURST-8E8K-WQ2F-ZDZ5-FQWHX
12:53:24:  [ Bitcoin ] 1UrayjqRjSJjuouhJnkczy5AuMqJGRK4b
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/19/shi-yong-kong-xian-de-ying-pan-jin-xing-burst-wa-k/" data-id="cjlyygokg003ff7vaan7zzvdj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rchain-jia-gou-wen-dang-fan-yi-motivation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/rchain-jia-gou-wen-dang-fan-yi-motivation/" class="article-date">
  <time datetime="2018-01-17T21:12:00.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/rchain-jia-gou-wen-dang-fan-yi-motivation/">Rchain 架构文档翻译（Motivation）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/rchain/architecture-docs/blob/master/introduction/motivation.rst" target="_blank" rel="noopener">原文</a></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>去中心化运动雄心勃勃，将为新的社会和经济提供绝佳的机遇。同时，去中心化平衡了权力集中的大型组织偶尔发生的滥权和腐败。去中心化运动使得自我决策，分散的社区组织大量出现。当然，分散的社区组织也将会面临挑战和问题，如法律问题，公共利益如何兑现等问题。</p>
<p>我们非常欣赏比特币，以太坊和其他平台的巨大创新，这些平台大大推进了去中心化组织的发展，迎来了加密货币和智能合约的新时代。但是，我们也看到这些项目没有使用最好的工程模型以支持扩展。目前社区正在热烈讨论的扩容问题和可靠性问题正反应了这些平台底层架构的不足。例如，对于在地球上进行的所有区块链交易，坚持一个明确的序列化处理顺序是否是可扩展的设计？</p>
<p>要成为具有工业规模的区块链解决方案，RChain必须以Facebook的规模提供内容支持，并以Visa的速度支持交易。对众多区块链项目的现状进行调查之后，与其他区块链开发团队的深入合作，了解了各自的路线图之后，我们得出结论：当前和近期的区块链架构不能满足这些要求。在2016年年中，我们决心设计一个更好的区块链架构。</p>
<p>与区块链行业一起，我们仍处于这种分散运动的曙光之中。现在是时候奠定坚实的基础。对于那些相信这个雄心勃勃的愿景的人来说，前进的道路是值得的，而且这份文件总结了这个愿景以及我们如何实现这一愿景。</p>
<h2 id="途径"><a href="#途径" class="headerlink" title="途径"></a>途径</h2><p>这个平台将实现以下最低要求：<br>* 动态的，响应式的，可证明正确的智能合约。<br>* 同时执行独立智能合约。<br>* 数据分离以减少独立代币和智能合约的不必要的数据复制。<br>* 保证节点到节点间通信的鲁棒性。<br>* 非计算密集型的共识算法/验证协议。</p>
<p>构建高质量的软件是非常具有挑战性的，相对来说构建一个看上去“聪明”的软件会容易的多。然而，由此产生的软件往往质量低劣，充满了缺陷，难以维护，难以发展。对于开发团队来说，继承和开发这样的软件对于他们以及他们的客户来说是残忍的。尤其是在构建一个用于支持重要任务的开源系统时，我们不会采用最小成功的思维模式，以此来保证软件的质量和正确性。</p>
<p>为了达到上述要求，我们的设计致力于以下几个方面：<br>* 一个假定细粒度并行和动态网络拓扑的计算模型。<br>* 一个可组合以及动态的资源寻址方案。<br>* 使用函数式编程范式，因为它更自然地适应分布式和并行处理。<br>* 严谨正式的验证，利用模型检查和定理证明。<br>* 遵循内涵和复合性原则。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/18/rchain-jia-gou-wen-dang-fan-yi-motivation/" data-id="cjlyygojs0022f7va7e9mzqe8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shi-yong-solidity-bian-xie-crypto-zombies-you-xi-s" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/17/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-s/" class="article-date">
  <time datetime="2018-01-17T03:17:42.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-s/">使用 Solidity 编写 Crypto Zombies 游戏（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是该系列的第三篇，前两篇文章详细描述了使用solidity编写一个游戏的必要步骤，实现了创建zombie，投食kitty等特性。这篇文章会介绍更多高级技巧，使我们的合约更加强大。</p>
<p>之前的投食功能有个小问题，kitty的合约地址是固定的。如果kitty的合约被杀死了会影响我们的合约，所以改为使用set函数来注入变量。</p>
<pre><code>address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
 KittyInterface kittyContract = KittyInterface(ckAddress);
</code></pre><p>改写为set函数：</p>
<pre><code>KittyInterface kittyContract;
function setKittyContractAddress(address _address) external onlyOwner {
  kittyContract = KittyInterface(_address);
}
</code></pre><p>这里使用了有个修饰符onlyOwner，这个修饰符来自于工具库，完整内容如下：</p>
<pre><code>/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &quot;user permissions&quot;.
 */
contract Ownable {
  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
</code></pre><p>实际上和我们手写require的效果一致，只是使用修饰符能让代码可读性更高。为了添加趣味性，下面我们来添加等级系统和冷却时间。等级系统很好理解，给每个zombie都加上等级属性，某些操作只有高于特定等级的zombie才能进行。至于冷却时间是用于限制投食的频率，增加游戏难度。理解了需求让我们给zombie添加两个属性，分别是level和readyTime。</p>
<pre><code>struct Zombie {
   string name;
   uint dna;
   uint32 level;
   uint32 readyTime;
}
</code></pre><p>需要编写一些帮助函数用于检测冷却时间。<br>_isReady</p>
<pre><code>function _isReady(Zombie storage _zombie) internal view returns (bool) {
      return (_zombie.readyTime &lt;= now);
  }
</code></pre><p>_triggerCooldown</p>
<pre><code>function _triggerCooldown(Zombie storage _zombie) internal {
    _zombie.readyTime = uint32(now + cooldownTime);
  }
</code></pre><p>在投食的时候需要先检查冷却时间是否满足条件，</p>
<pre><code>function feedAndMultiply(uint _zombieId, uint _targetDna, string species) internal {
  require(msg.sender == zombieToOwner[_zombieId]);
  Zombie storage myZombie = zombies[_zombieId];
  // 检测冷却时间是否合格
  require(_isReady(myZombie));
  _targetDna = _targetDna % dnaModulus;
  uint newDna = (myZombie.dna + _targetDna) / 2;
  if (keccak256(species) == keccak256(&quot;kitty&quot;)) {
    newDna = newDna - newDna % 100 + 99;
  }
  _createZombie(&quot;NoName&quot;, newDna);
  // 重置冷却时间
  _triggerCooldown(myZombie);
}
</code></pre><p>对于某些操作要求特定等级的，可以定义一个aboveLevel修饰符</p>
<pre><code>modifier aboveLevel(uint _level, uint _zombieId) {
  require(zombies[_zombieId].level &gt;= _level);
  _;
}
</code></pre><p>修饰符也是函数，所以也可以传入参数。在使用的时候就和调用函数一样。</p>
<pre><code>function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
  require(msg.sender == zombieToOwner[_zombieId]);
  zombies[_zombieId].name = _newName;
}

function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
  require(msg.sender == zombieToOwner[_zombieId]);
  zombies[_zombieId].dna = _newDna;
}
</code></pre><p>至此，我们完成了两个高级功能，等级系统和冷却时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/17/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-s/" data-id="cjlyygokj003mf7va432mww03" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shi-yong-solidity-bian-xie-crypto-zombies-you-xi-e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-e/" class="article-date">
  <time datetime="2018-01-16T04:42:37.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-e/">使用 Solidity 编写 Crypto Zombies 游戏（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇文章我们实现了一个基于以太坊的智能合约游戏，这篇文章会继续介绍solidity，并且丰富智能合约，添加更多的功能。之前介绍了struct和array数据类型，除此之外，solidity还支持mapping类型，定义一个mapping：</p>
<pre><code>mapping (address =&gt; uint) public accountBalance;
</code></pre><p>mapping类型通常用于存储账户的信息，比如在这个游戏里我们需要记录账户拥有的zombie数量，那么可以定义一个ownerZombieCount变量，类型是mapping (address =&gt; uint)，在每次生成zombie的时候往ownerZombieCount里添加一条记录。</p>
<pre><code>function _createZombie(string _name, uint _dna) private {
      uint id = zombies.push(Zombie(_name, _dna)) - 1;
      ownerZombieCount[msg.sender]++;
      NewZombie(id, _name, _dna);
  }
</code></pre><p>上面的代码添加了ownerZombieCount变量，通过solidity内置的变量msg.sender可以获得智能合约的调用者。solidity内置了许多全局变量(<a href="http://solidity.readthedocs.io/en/develop/units-and-global-variables.html" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/develop/units-and-global-variables.html)。</a>%E3%80%82)<br>1. msg.data (bytes): 完整的调用消息体<br>2. msg.gas (uint): 剩余的gas<br>3. msg.sender (address): 当前合约的调用者<br>4. msg.sig (bytes4): 调用消息体前四位<br>5. msg.value (uint): 发送的以太币数目（以 wei 为单位）</p>
<p>其中msg.sender是用于获取智能合约调用者的地址，使用msg.sender和mapping变量就可以记录每个账户拥有多少只zombie，但是游戏还需要记录每只zombie的归属，所以需要再添加一个zombieToOwner变量，在生成zombie的时候顺便记录zombie的归属账户。</p>
<pre><code>// key是zombie的编号 value是账户地址
mapping (uint =&gt; address) public zombieToOwner;
</code></pre><p>接下来需要实现喂食功能，玩家可以给自己的zombie投喂食物，这里使用以太坊猫作为食物！（哈哈哈，有点丧心病狂~~）所以需要调用以太猫的智能合约，在第一篇文章里介绍了使用web3js调用智能合约的方法，在solidity里使用类似的方法，略微不同的是需要实现定义调用contract的接口。接口也是使用contract关键字声明，但是不同的接口只有定义没有具体实现。下面是以太猫的接口定义：</p>
<pre><code>contract KittyInterface {
  function getKitty(uint256 _id) external view returns (
    bool isGestating,
    bool isReady,
    uint256 cooldownIndex,
    uint256 nextActionAt,
    uint256 siringWithId,
    uint256 birthTime,
    uint256 matronId,
    uint256 sireId,
    uint256 generation,
    uint256 genes
  );
}
</code></pre><p>KittyInterface这个智能合约接口包含了一个getKitty方法，返回多个返回值。有了接口，只需要传入智能合约实际的地址即可生成一个智能合约实例，然后就可以调用智能合约的方法。</p>
<pre><code>address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
KittyInterface kittyContract = KittyInterface(ckAddress);
uint kittyDna;
(,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
</code></pre><p>因为只需要最后一个返回值即以太猫的DNA，所以之前的返回值可以忽略。添加一个投食函数：</p>
<pre><code>function feedAndMultiply(uint _zombieId, uint _targetDna, string species) public {
    // 确保玩家只能投食自己的zombie
    require(msg.sender == zombieToOwner[_zombieId]);
    // 使用storage关键字表示获取对象的引用
    Zombie storage myZombie = zombies[_zombieId];
    // 生成新的DNA
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    // 如果投食的物种是kitty 最后两位设置为99
    if (keccak256(species) == keccak256(&quot;kitty&quot;)) {
      newDna = newDna - newDna % 100 + 99;
    }
    _createZombie(&quot;NoName&quot;, newDna);
  }
</code></pre><p>上述代码有几点需要解释一下：<br>使用require来限制玩家只能投食自己的zombie，require是solidity提供的一种保护机制，如果条件不满足会抛出异常，终止合约的执行。<br>使用storage关键字表示获取对象的引用，在函数内的变量默认是内存型变量，不会永久存储，如果我们想修改永久存储对象就需要storage来修饰变量。<br>因为需要考虑未来的扩展性，比如增加其他投食选项，我们使用最后两位来标示投食物种。<br>现在我们增加了投食功能，玩家可以选择以太猫来喂食自己的zombie，整个智能合约看上去有些过长了，让我们来重构一些地方。继承是solidity提供的一个高级语法，和其他面向对象的语言一样，使用is关键字来进行继承关系指定。</p>
<pre><code>contract ZombieFeeding is ZombieFactory {
}
</code></pre><p>同时把两个合约拆分成两个文件，zombiefeeding.sol和zombiefactory.sol。这里需要修改_createZombie函数的可见性，之前使用private修饰符，拆分成继承关系后会报错。修改private为internal解决这个问题。总共由四种可见性修饰符，这里介绍一下各种可见性修饰符的区别：<br>1. public：所有人都可以访问<br>2. external：只有外部合约能访问，禁止内部合约访问<br>3. internal：允许内部和继承的合约访问<br>4. private：不允许外部和继承的合约访问</p>
<p>让我们看一看拆分后的两个文件：<br>zombiefactory.sol</p>
<pre><code>pragma solidity ^0.4.19;
contract ZombieFactory {

    event NewZombie(uint zombieId, string name, uint dna);
    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zombie {
        string name;
        uint dna;
    }

    Zombie[] public zombies;

    mapping (uint =&gt; address) public zombieToOwner;
    mapping (address =&gt; uint) ownerZombieCount;

    function _createZombie(string _name, uint _dna) internal {
        uint id = zombies.push(Zombie(_name, _dna)) - 1;
        zombieToOwner[id] = msg.sender;
        ownerZombieCount[msg.sender]++;
        NewZombie(id, _name, _dna);
    }

    function _generateRandomDna(string _str) private view returns (uint) {
        uint rand = uint(keccak256(_str));
        return rand % dnaModulus;
    }

    function createRandomZombie(string _name) public {
        require(ownerZombieCount[msg.sender] == 0);
        uint randDna = _generateRandomDna(_name);
        randDna = randDna - randDna % 100;
        _createZombie(_name, randDna);
    }

}
</code></pre><p>zombiefeeding.sol</p>
<pre><code>pragma solidity ^0.4.19;
// 引入其他文件
import &quot;./zombiefactory.sol&quot;;

// 定义以太猫的接口
contract KittyInterface {
  function getKitty(uint256 _id) external view returns (
    bool isGestating,
    bool isReady,
    uint256 cooldownIndex,
    uint256 nextActionAt,
    uint256 siringWithId,
    uint256 birthTime,
    uint256 matronId,
    uint256 sireId,
    uint256 generation,
    uint256 genes
  );
}

// 定义一个新的ZombieFeeding智能合约并继承自ZombieFactory
contract ZombieFeeding is ZombieFactory {

  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
  KittyInterface kittyContract = KittyInterface(ckAddress);

  function feedAndMultiply(uint _zombieId, uint _targetDna, string species) public {
    require(msg.sender == zombieToOwner[_zombieId]);
    Zombie storage myZombie = zombies[_zombieId];
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    if (keccak256(species) == keccak256(&quot;kitty&quot;)) {
      newDna = newDna - newDna % 100 + 99;
    }
    _createZombie(&quot;NoName&quot;, newDna);
  }

// 投食以太猫
  function feedOnKitty(uint _zombieId, uint _kittyId) public {
    uint kittyDna;
    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);
  }
}
</code></pre><p>本文在原来第一篇文章的基础上增加了投食功能，并且重构了原文件，下一篇文章我们继续优化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/16/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-e/" data-id="cjlyygokh003if7va1nsnayyg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-shi-yong-solidity-bian-xie-crypto-zombies-you-xi-y" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/15/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-y/" class="article-date">
  <time datetime="2018-01-15T00:28:19.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-y/">使用 Solidity 编写 Crypto Zombies 游戏（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近一款名为以太猫的小游戏火了，以太猫是一款基于以太坊的宠物游戏，用户可以使用以太坊账户生成自己的宠物，每只宠物有自己独特的DNA（一个随机数字）。用户可以通过喂食来养大宠物，同时用户可以出售自己的宠物来赚取以太坊代币。而Crypto Zombies和以太猫一样，也是一款基于以太坊的电子宠物培养游戏，用户使用以太坊来培养僵尸宠物。在Crypto Zombies中给宠物喂食会改变宠物的DNA，从而改变宠物的外貌，同时Crypto Zombies会有等级系统和格斗系统。</p>
<p>本文是Crypto Zombies的简单实现，通过solidity编写智能合约。首先介绍一些solidity的基本知识。在solidity里使用contract关键字标示一个智能合约，类似很多语言里的class，一个contract有自己的状态，有独立的命名空间，也有自己的方法。</p>
<p>一个简单contract：</p>
<pre><code>pragma solidity ^0.4.19;
contract ZombieFactory {
    //start here
}
</code></pre><p>第一行是solidity的版本声明，因为以太坊目前还在不断更新，所以solidity 需要一个版本号以便编译器做兼容。第二行使用了contract关键字来声明一个智能合约。</p>
<p>和主流语言一样，solidity支持常见的运算符：<br>1. 加法: x + y<br>2. 减法: x - y,<br>3. 乘法: x * y<br>4. 除法: x / y<br>5. 取模运算: x % y<br>6. 指数运算：**</p>
<p>支持多种变量声明：<br>1. uint(uint8,uint32)<br>2. string<br>3. address<br>4. struct</p>
<p>uint是整数，可以选择uint8或者uint32来控制大小，这在定义struct结构体的时候比较有用，因为在以太坊中struct中uint成员越小消耗的gas越低。string是字符串类型。address是一个比较特殊的类型，表示一个账户地址。struct和其他语言的结构体类似，是一种自定义的数据结构。</p>
<p>数组定义：<br>在类型后面加上中括号就是数组的定义，uint[],string[],address[]。使用push方法可以往数组里添加元素。</p>
<p>申明一个函数：<br>Solidity使用function关键字声明一个函数，函数的定义需要指定入参，也可以指定返回值，函数可见性，装饰器。</p>
<p>有了以上的知识，我们就可以创建一个 ZombieFactory 的智能合约，用于生产 Zombie宠物。<br>zombieFactory.sol</p>
<pre><code>pragma solidity ^0.4.19;

contract ZombieFactory {
    // 限制DNA的长度
    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;

    // 每次创建一个新的Zombie会发出一个事件
    event NewZombie(uint zombieId, string name, uint dna);

    // 使用struct定义Zombie
    struct Zombie {
        string name;
        uint dna;
    }
    // 使用一个数组来记录所有生成的Zombie
    Zombie[] public zombies;

    // 声明一个创建Zombie的函数
    function createZombie(string _name, uint _dna) {
        zombies.push(Zombie(_name, _dna));
        // 发出一个事件
        NewZombie(id, _name, _dna);
    }

    // 声明一个生产随机DNA的函数 使用private规定函数的可见性，使用view表示函数只查看数据不修改数据。
    function _generateRandomDna(string _str) private view returns (uint) {
        uint rand = uint(keccak256(_str));
        return rand % dnaModulus;
    }

    // 调用_generateRandomDna和createZombie生成Zomobie     
    function createRandomZombie(string _name) public {
        uint randDna = _generateRandomDna(_name);
        _createZombie(_name, randDna);
    }


}
</code></pre><p>上面的代码就是我们的智能合约ZombieFactory，通过命令行编译后得到智能合约的api，部署到主网后得到智能合约的地址。使用web3.js可以从前端发起智能合约的调用。捕捉用户输入参数，调用createRandomZombie方法生成一个带有随机DNA的Zombie。</p>
<p>前端调用：</p>
<pre><code>// 智能合约编译后得到的abi
var abi = myAbi
var ZombieFactoryContract = web3.eth.contract(abi)
// 智能合约部署后得到的账户地址
var contractAddress = myAddress
// 生成一个智能合约对象
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// 捕捉用户点击事件
$(&quot;#ourButton&quot;).click(function(e) {
  var name = $(&quot;#nameInput&quot;).val()
  // 调用智能合约的方法
  ZombieFactory.createRandomZombie(name)
})
</code></pre><p>这里有个小问题：web3.js是如何捕获返回的结果呢？Solidity使用了一种消息通知的机制，因为区块链系统不是一个高吞吐的系统，不能立马返回结果，所以只能依靠这种异步的方式处理。使用event关键字声明一个事件，在事件发生处通过类似调用函数的语法来触发一个事件。</p>
<pre><code>// 每次创建一个新的Zombie会发出一个事件
event NewZombie(uint zombieId, string name, uint dna);

function createZombie(string _name, uint _dna) {
   zombies.push(Zombie(_name, _dna));
   // 触发一个事件
   NewZombie(id, _name, _dna);
}
</code></pre><p>前端监听智能合约提供的事件：</p>
<pre><code>// 监听智能合约的NewZombie事件
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})
</code></pre><p>到此已经完成了一个简单的Crypto Zombies游戏原型，下一篇文章会介绍更多的solidity特性，以便我们丰富这个游戏的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/15/shi-yong-solidity-bian-xie-crypto-zombies-you-xi-y/" data-id="cjlyygokl003pf7valyqc55xi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-qu-kuai-lian-gong-shi-suan-fa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/12/qu-kuai-lian-gong-shi-suan-fa/" class="article-date">
  <time datetime="2018-01-12T09:20:27.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/qu-kuai-lian-gong-shi-suan-fa/">区块链共识算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><p>共识算法是区块链技术的核心，共识算法的目的是让全网达成存储上的一致。在一个分布式的环境下如何能让独立的几点达成状态上的一致呢？因为节点是独立的，节点之间通过网络通信，这种情况下会有很多干扰因素，比如网络的中断或者延迟，某几个参与节点宕机。这个问题最早是由莱斯利·兰伯特提出，并且给它取名为：拜占庭将军问题（Byzantine failures）。含义是在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。因此对一致性的研究一般假设信道是可靠的。</p>
<p>为了解决这个问题，陆续出现了几个算法，最著名的是Paxos算法，zookeeper使用的就是Paxos。因为Paxos较为复杂，难以理解，难以实现，所以后来有人简化了Paxos，提出了Raft一致性算法。这两个算法都是主从算法，节点会有角色区分，主节点负责写入，从节点负责复制备份，如果主节点挂了会有个选举的过程重新选出主节点，保证集群的可用性。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/01/15157392891214.jpg" alt="">￼</p>
<p>Raft的详细解释（<a href="http://www.jdon.com/artichect/raft.html%EF%BC%89" target="_blank" rel="noopener">http://www.jdon.com/artichect/raft.html）</a> 。但是这些算法都有一个较大的问题，即默认集群中的节点都是可信任的，也就是假设节点不会作恶，节点只会受到偶然因素的干扰而不会主动篡改数据。所以以上两个算法都不能作为区块链公有链应用的共识算法（企业链和联盟链除外）。</p>
<h2 id="比特币-以太坊-POW"><a href="#比特币-以太坊-POW" class="headerlink" title="比特币 以太坊 POW"></a>比特币 以太坊 POW</h2><p>比特币的共识算法即POW（工作量证明算法）主要解决了一个可信问题，灵感来自与早期抵抗垃圾邮件攻击而采取的策略。电子邮件刚出现的时候面临一个垃圾邮件攻击的严重问题，作恶者只需要付出极低的成本就可以发送成千上万的垃圾邮件，对指定目标进行攻击。为了遏制这种攻击，有人提出了一种策略，即在发送邮件之前需要发送者做一定的hash运算，提高发送者发送邮件的成本。这个方案在发送一封邮件的时候不会有太多变化，但是随着发送邮件数量的增多会极大消耗攻击者的资源，从一定程度上提高了攻击者的成本从而遏制住垃圾邮件攻击。</p>
<p>比特币的POW也是出于同样的原理，每个节点执行所谓的挖矿程序，流程如下：<br>1. 节点通过hash运算计算区块头和随机数的hash值<br>2. 对比hash值是否满足难度值的要求<br>3. 如果满足要求，打包区块，并且向全网广播。<br>4. 如果不满足，更换随机数，重新从第一个步骤开始。</p>
<p>过程很简单，但是有几个问题需要回答。<br>* 为什么要选择区块头作为hash计算内容？<br>* 随机数如何选择？<br>* 难度值的要求是什么？<br>* 难度值是固定的么？<br>* 全网广播不是瞬间达成的，如何解决延迟问题？<br>* 存在攻击么？</p>
<h3 id="为什么选择区块头作为hash计算内容？"><a href="#为什么选择区块头作为hash计算内容？" class="headerlink" title="为什么选择区块头作为hash计算内容？"></a>为什么选择区块头作为hash计算内容？</h3><p>因为hash头里面有交易信息，旷工会优先选择交易手续费高的交易优先打包，而这些交易信息是无法事先预知的，所以每个头都是独一无二的。</p>
<h3 id="随机数如何选择？"><a href="#随机数如何选择？" class="headerlink" title="随机数如何选择？"></a>随机数如何选择？</h3><p>没有任何要求，可以使用伪随机数，寻找随机数本身是一个暴利枚举的过程。初始值通过随机算法产生一个seed，每一轮计算完hash，如果不满足难度值的要求就自增，重新开始一轮计算。</p>
<h3 id="难度值的要求是什么？"><a href="#难度值的要求是什么？" class="headerlink" title="难度值的要求是什么？"></a>难度值的要求是什么？</h3><p>所谓的要求实际上是计算得到的hash值必须满足一定要求。举个列子，现在的难度值是4，那么计算得到的hash值前4位必须都是0。df7cb8d8d289b4a4a7ea503574eeefb57a8e8a6d 这个hash值就不满足要求，而 0000cb8d8d289b4a4a7ea503574eeefb57a8e8a6d 这个hash值满足要求。而产生 0000cb8d8d289b4a4a7ea503574eeefb57a8e8a6d 这个hash值的随机数就是挖矿程序寻找的目标。</p>
<h3 id="难度值是固定的么？"><a href="#难度值是固定的么？" class="headerlink" title="难度值是固定的么？"></a>难度值是固定的么？</h3><p>难度值是动态调整的，调整算法以以太坊为例：</p>
<pre><code>diff = (parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99)) ) + 2^(periodCount - 2)
</code></pre><p>简单描述：diff = parent_diff + 难度调整 + 难度炸弹<br>难度调整部分：(parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))<br>难度炸弹部分：2periodCount - 2<br>难度调整部分和出块时间相关，(timestamp - parent.timestamp) // 9，出块间隔越长难度调整越小。难度炸弹和区块高度有关，高度越高难度越大。整体的难度调整原则是：区块高度越高难度越高，出块时间间隔如果过长，那么适当降低难度。<br>下图是以太坊的难度调整示意图，可以看到随着区块高度的增加难度在逐渐攀升。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/01/15157392305410.jpg" alt="">￼</p>
<h3 id="全网广播不是瞬间达成的，如何解决延迟问题？"><a href="#全网广播不是瞬间达成的，如何解决延迟问题？" class="headerlink" title="全网广播不是瞬间达成的，如何解决延迟问题？"></a>全网广播不是瞬间达成的，如何解决延迟问题？</h3><p>网络延迟是不可避免的，那么就会出现这么一种情况：节点A打包了一个区块1开始向全网广播，但是因为网络延迟全球的节点不可能瞬间就接受到这个请求。同一时间，节点B也打包了一个区块2并向全网广播，又因为这两个节点网络距离很远，相互不知道对方的存在，所以在A周围的节点会接受区块1，并且在这个基础上继续挖矿。而B周围会接受区块2，同样在这个基础上继续挖矿。这就产生了所谓的分叉问题。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/01/15157394213395.jpg" alt="">￼</p>
<p>如何解决呢？这里需要引入一个验证的共识，到底使用哪条链不是A说了算，也不是B说了算，而是验证的客户端说了算。客户端怎么选择链呢？这个规则肯定是由接受方的客户端说了算，这个很好理解，你付款购买必须得到对方的承认。那么接受客户端该怎么选呢？默认选择最长的链作为胜出的链，这个逻辑的依据是如果一条链更长说明这条链获得的算力更多，那么这条链就更安全。那么如何处理被废弃的链，因为被废弃的链不会被客户端认可，所以旷工为了避免算力浪费肯定会重新选择更长的链进行挖矿，这就达成了重新共识。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/01/15157394397043.jpg" alt="">￼</p>
<p>接下来另一个问题出现了：会不会出现某条被废弃的链突然变成了全网最长的链？答案是有可能，怎么避免这个问题？一个简单有效的方案是等待一段时间。因为区块链是不断增长的，如果客户端要验证的交易已经过去几十个区块了，基本可以判定不会出现大面积的算力切换，导致最长链被替换的情况，这也是为什么所有客户端都会有确认时间的概念，其实就是在等待区块增长。</p>
<h3 id="存在攻击么？"><a href="#存在攻击么？" class="headerlink" title="存在攻击么？"></a>存在攻击么？</h3><p>基于上面的POW算法原理，实施算力攻击是完全可能的。只要你掌握了全网51%的算力你就可以任意更改区块的内容！但是没人会这么干，原理和阻止邮件攻击一样，如果有人发动了算力劫持，那整个系统会被摧毁，但是这样做需要耗费极大的资源，并且对攻击者本身没有一丝好处。相反，如果使用这些算力保护系统就可以获得巨额的利润，在这种情况下是没人会去发动攻击的。另一个方面，比特币的去中心化已经不是技术层面的去中心化了，中本聪在发表比特币后自身就隐退了，所以无论从哪个方面来看比特币都是一个中立的事物。</p>
<h2 id="POS-和-DPOS"><a href="#POS-和-DPOS" class="headerlink" title="POS 和 DPOS"></a>POS 和 DPOS</h2><p>POS（股权证明）和DPOS（委任权益证明）是一种来源于公司股份制度的共识算法，没有太多技术方面的内容。POS会根据你持有数字货币的量和时间，分配给你相应的利息。持有的币数目越多，时间越长分到的利息越高，这种制度能保证网络的稳定，和POW的原理一样，持有代币的人投资了这个系统，如果他作恶，会导致系统奔溃而造成损失。DPOS在POS的基础上更进一步，采用了委托的机制，让每一个持有币的人进行投票，由此产生固定数目的代表，我们可以将其理解为超级节点或者矿池。从某种角度来看，DPOS完全是POW的另一种表达形式，POW的初衷没有料想到会有矿机和矿池的产生，但是目前的现状就是大矿池掌握了算力，个体挖矿需要选择一个矿池。DPOS把这个过程更直接的表述出来，直接使用代币进行投票，选出来的代表其实就是矿池。如果代表作恶，个体持币者可以重新投票更换代表。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文总简单总结了几种共识算法，重点还是比特币和以太坊采用的POW算法，对于未来或许还会有更多新的更先进的共识算法出现，但是作为第一个成功的大规模应用的共识算法POW是必须要了解的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/12/qu-kuai-lian-gong-shi-suan-fa/" data-id="cjlyygojp001wf7vauievd0t2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-yi-tai-fang-cun-chu-ti-xi" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/12/yi-tai-fang-cun-chu-ti-xi/" class="article-date">
  <time datetime="2018-01-12T02:54:40.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/BlockChain/">BlockChain</a>►<a class="article-category-link" href="/categories/BlockChain/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/yi-tai-fang-cun-chu-ti-xi/">以太坊存储体系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Merkle-Tree（默尔克树-比特币）"><a href="#Merkle-Tree（默尔克树-比特币）" class="headerlink" title="Merkle Tree（默尔克树 比特币）"></a>Merkle Tree（默尔克树 比特币）</h2><p>默尔克树是比特币采用的交易存储结构，比特币使用这个结构的目的是用于轻量客户端的快速验证。默尔克树的叶子节点为文件块（一笔交易信息），每个文件块进行hash计算的到transaction id。两两一对，将得到的hash值再次进行hash计算，重复上述步骤，直到得到root hash,即整棵树的根节点。<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/01/15090723026362.jpg" alt="">￼<br>如果叶子节点是奇数，那么复制最后一笔交易得到偶数笔交易。merkle tree 只存储hash，也就是上图红色的部分。默尔克树的特点是可以根据某个叶子hash值，以及一条路径来证明这个叶子节点是否存在于这棵树中。在比特币中就是用于证明一笔交易是否存在于一个区块里，以此来判断交易是否生效。</p>
<h2 id="SPV"><a href="#SPV" class="headerlink" title="SPV"></a>SPV</h2><p>上面说了，默尔克树的作用就是用于快速验证，全称 Simplified Payment Verification(简单支付验证)。所以接下来我们来介绍一下SPV是什么东西。<br>下面是SPV验证支付的简化流程：<br>1. spv client通过bloom filter向相邻全节点注册本身感兴趣的地址。<br>2. 如果有相关的交易和注册的地址相关，全节点通知spv。<br>3. 从网络上获取并保存最长链的所有block header至本地<br>4. 下载包含transaction的完整区块BLK1<br>5. 通过完整区块BLK1生成merkle tree MT1<br>6. 通过对比MT1和本地header列表里的merkle tree来验证MT1存在本地的header列表里。<br>7. 根据该block header所处的位置，确定该交易已经得到多少个确认。<br>8. 不断更新本地block header列表，重复6-8步骤，直到深度达到安全要求。</p>
<p>第一步需要解释一下，因为spv不需要监听所有账户的变化，如果监听所有账户的余额变化会给全节点造成很大的压力。所以spv会使用bloom filter去过滤地址。全节点通过spv发送来的bloom filter来筛选地址。但是这里的bloom filter也不是完全准确的，因为完全准确的地址会泄露spv的隐私信息。</p>
<p>简单说就是通过默尔克树来生成一个验证数据，spv只需要下载交易头就能做验证。这么做的优点是极大地节省存储空间。减轻终端用户的负担。无论未来的交易量有多大，block header的大小始终不变，只有80字节。按照每小时6个的出块速度，每年产出52560个区块。当只保存block header时，每年新增的存储需求约为4兆字节，100年后累计的存储需求仅为400兆，即使用户使用的是最低端的设备，正常情况下也完全能够负载。</p>
<h2 id="Merkle-Patricia-Tree（默尔克-帕特丽夏树-以太坊）"><a href="#Merkle-Patricia-Tree（默尔克-帕特丽夏树-以太坊）" class="headerlink" title="Merkle Patricia Tree（默尔克-帕特丽夏树 以太坊）"></a>Merkle Patricia Tree（默尔克-帕特丽夏树 以太坊）</h2><p>以太坊和比特币相似，使用一种改进的名为：默尔克-帕特丽夏树的结构。相比比特币的UTXO模型而言，以太坊使用的是账户模型，所有的账户信息都存储在树的数据结构中。帕特丽夏树的叶子节点都是k-v形式的存储，key分不同类型：<br>* extension node（扩展节点）hashNode<br>* branch node（分支节点）fullNode<br>* leaf node（叶子节点）shortNode<br>对应的在代码中的定义（go-eth）：</p>
<pre><code>type (
    fullNode struct {
        Children [17]node 
        flags    nodeFlag
    }
    shortNode struct {
        Key   []byte
        Val   node
        flags nodeFlag
    }
    hashNode  []byte
    valueNode []byte
)
</code></pre><p>value编码总共有三种类型：<br>* null 末节点<br>* k-v数组 [[k,v],[k,v]…] 存储叶子节点<br>* [v0,v1…,v15,vt] 17个值，vt是存储值的，代表branch节点</p>
<p>world state trie 示意图：<br><img src="http://linshengsheng.vip/wp-content/uploads/2018/01/15090765422679.jpg" alt="">￼</p>
<p>trie.go tryGet 代码</p>
<pre><code>func (t *Trie) tryGet(origNode node, key []byte, pos int) (value []byte, newnode node, didResolve bool, err error) {
    switch n := (origNode).(type) {
    case nil:
        return nil, nil, false, nil
    case valueNode:
        return n, n, false, nil
    case *shortNode:
        if len(key)-pos &lt; len(n.Key) || !bytes.Equal(n.Key, key[pos:pos+len(n.Key)]) {
            // key not found in trie
            return nil, n, false, nil
        }
        value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+len(n.Key))
        if err == nil &amp;&amp; didResolve {
            n = n.copy()
            n.Val = newnode
            n.flags.gen = t.cachegen
        }
        return value, n, didResolve, err
    case *fullNode:
        value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+1)
        if err == nil &amp;&amp; didResolve {
            n = n.copy()
            n.flags.gen = t.cachegen
            n.Children[key[pos]] = newnode
        }
        return value, n, didResolve, err
    case hashNode:
        child, err := t.resolveHash(n, key[:pos])
        if err != nil {
            return nil, n, true, err
        }
        value, newnode, _, err := t.tryGet(child, key, pos)
        return value, newnode, true, err
    default:
        panic(fmt.Sprintf(&quot;%T: invalid node: %v&quot;, origNode, origNode))
    }
}
</code></pre><p>总结上述的代码：<br>* 如果是hashNode，从数据库中读取hash索引的具体值。<br>* 如果是fullNode，根据pos获取子节点，同时pos加1表示key的位置前进了一位。<br>* 如果是shortNode，提取shortNode的Value作为子节点，同时pos增加shortNode的Value长度，这是因为存在一个优化：当试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时把剩余的Key存储在shortNode的Key字段中，充当一个”Shortcut“。</p>
<p>另外还有一点，以太坊使用了RLP编码存储在数据库中的数据，这是一种编码算法，用于编码任意的嵌套结构的二进制数据，它是以太坊中数据序列化/反序列化的主要方法，区块、交易等数据结构在持久化时会先经过RLP编码后再存储到数据库中。详细解释参考：<a href="http://ethfans.org/posts/415" target="_blank" rel="noopener">http://ethfans.org/posts/415</a></p>
<h2 id="其他相关："><a href="#其他相关：" class="headerlink" title="其他相关："></a>其他相关：</h2><p>detect_internal_storage.py<br>输入根哈希值，得到所有叶子节点信息，代码如下所示：</p>
<pre><code>#!/usr/bin/env python
# coding=utf-8

import leveldb
from ethereum import utils
import rlp
import sys

db = leveldb.LevelDB(&quot;/Users/likang/private_ethereum/ss_ethereum/geth/chaindata&quot;)

accountHash2content = {}

def getAccountInfoByStateRoot(st, key) :
    #print &quot;root : &quot; + st.encode(&quot;hex&quot;)
    root_node = rlp.decode(db.Get(st))

    if len(root_node) == 2 :
        if root_node[0][0].encode(&quot;hex&quot;)[0] == &quot;2&quot; :
            key += root_node[0].encode(&quot;hex&quot;)[2:]
            accountHash2content[key] = rlp.decode(root_node[1])
            #print key
            return
        elif root_node[0][0].encode(&quot;hex&quot;)[0] == &quot;3&quot; :
            key += root_node[0].encode(&quot;hex&quot;)[1:]
            #print key
            accountHash2content[key] = rlp.decode(root_node[1])
            return
        else :
            if root_node[0][0].encode(&quot;hex&quot;)[0] == &quot;0&quot; :
                key += root_node[0].encode(&quot;hex&quot;)[2:]
            else :
                key += root_node[0].encode(&quot;hex&quot;)[1:]

            getAccountInfoByStateRoot(root_node[1], key)
    else :
        for i in range(10) :
            if root_node[i] != &quot;&quot; :
                getAccountInfoByStateRoot(root_node[i], key + str(i))
        for i in range(6):
            if root_node[10 + i] != &quot;&quot; :
                getAccountInfoByStateRoot(root_node[10 + i], key + chr(97 + i))
        if root_node[16] != &quot;&quot; :
            getAccountInfoByStateRoot(root_node[16], key)

if __name__ == &quot;__main__&quot; :

    getAccountInfoByStateRoot(sys.argv[1].decode(&quot;hex&quot;), &quot;&quot;)
    for key in accountHash2content :
        print key + &quot; : &quot;,
        print accountHash2content[key]
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2018/01/12/yi-tai-fang-cun-chu-ti-xi/" data-id="cjlyygokt004af7vah01gvgf7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sass-xiao-jie-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/25/sass-xiao-jie-2/" class="article-date">
  <time datetime="2017-12-25T04:11:54.000Z" itemprop="datePublished">2017-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>►<a class="article-category-link" href="/categories/Web/技术积累/">技术积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/25/sass-xiao-jie-2/">Sass 小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前端的CSS和JS都存在很多问题，其中完善CSS的解决方案有好几种，本文介绍的Sass是其中一种。这些解决方案会引入很多方便的语法，本文做一个简单的小结。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>$highlight-color: #F90;
.selected {
  border: 1px solid $highlight-color;
}

//编译后

.selected {
  border: 1px solid #F90;
}
</code></pre><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><pre><code>#content {
  article {
    h1 { color: #333 }
    p { margin-bottom: 1.4em }
  }
  aside { background-color: #EEE }
}
</code></pre><h2 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符&amp;"></a>父选择器的标识符&amp;</h2><pre><code>sass:
article a {
  &amp;:hover { color: red }
}

css: 
article a:hover { color: red }
</code></pre><h2 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套"></a>群组选择器的嵌套</h2><pre><code>css: 
.container h1, .container h2, .container h3 { margin-bottom: .8em }

sass:
.container {
  h1, h2, h3 {margin-bottom: .8em}
}
</code></pre><h2 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h2><pre><code>sass:
nav {
  border: {
  style: solid;
  width: 1px;
  color: #ccc;
  }
}

css:
nav {
  border-style: solid;
  border-width: 1px;
  border-color: #ccc;
}
</code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>子组合选择器&gt;选择一个元素的直接子元素<br>同层相邻组合选择器+选择元素后紧跟的元素<br>同层全体组合选择器~，选择所有跟在元素后的同层元素，不管它们之间隔了多少其他元素</p>
<h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><pre><code>@mixin rounded-corners {
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}
notice {
  background-color: green;
  border: 2px solid #00aa00;
  @include rounded-corners;
}
</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code>//.seriousError从.error继承样式
.error a{  //应用到.seriousError a
  color: red;
  font-weight: 100;
}
h1.error { //应用到hl.seriousError
  font-size: 1.2rem;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linsheng9731.github.io/2017/12/25/sass-xiao-jie-2/" data-id="cjlyygok5002yf7vadb4alpm5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/">Ansible</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/技术积累/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ansible/工具/运维/">运维</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/BlockChain/">BlockChain</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/BlockChain/技术积累/">技术积累</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/Marathon/">Marathon</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/Marathon/工具/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/Marathon/工具/技术积累/">技术积累</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Marathon/">Marathon</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Marathon/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Marathon/技术积累/运维/">运维</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/Web/">Web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/Web/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/Web/技术积累/未分类/">未分类</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/技术积累/">技术积累</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/技术积累/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术积累/">技术积累</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/收藏/">收藏</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ansible/">Ansible</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Marathon/">Marathon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rchain/">rchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术文档/">技术文档</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ansible/" style="font-size: 12px;">Ansible</a> <a href="/tags/Marathon/" style="font-size: 16px;">Marathon</a> <a href="/tags/Scala/" style="font-size: 18px;">Scala</a> <a href="/tags/Web/" style="font-size: 16px;">Web</a> <a href="/tags/blockchain/" style="font-size: 20px;">blockchain</a> <a href="/tags/golang/" style="font-size: 12px;">golang</a> <a href="/tags/rchain/" style="font-size: 10px;">rchain</a> <a href="/tags/大数据/" style="font-size: 18px;">大数据</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/技术文档/" style="font-size: 14px;">技术文档</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/12/Spark-潜规则/">Spark 潜规则</a>
          </li>
        
          <li>
            <a href="/2018/06/11/yi-tai-fang-ri-zhi/">以太坊日志</a>
          </li>
        
          <li>
            <a href="/2018/04/28/kubernetes-kuai-su-shang-shou/">Kubernetes 快速上手</a>
          </li>
        
          <li>
            <a href="/2018/04/25/rchain-jian-zao-zheng-que-de-gong-shi-xie-yi/">Rchain 建造正确的共识协议</a>
          </li>
        
          <li>
            <a href="/2018/04/23/yi-tai-fang-xiang-guan-mi-ma-xue-suan-fa/">以太坊相关密码学算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Damon Lin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>